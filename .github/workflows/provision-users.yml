name: Provision Users on AWS EC2 Instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Select EC2 instance ID from the dropdown'
        required: true
        type: choice
        options:
          - i-0d2ea774d38f88fe2
          - i-059108826eb667a3d
          - i-03810d57b29eff7fa
          - i-04f6cf69514fab8ec
          - i-069c4707f66eee735
          - i-038146dc9a729c973
          - i-0ce61b84050ece568
          - i-0079b3bcbc7b9c83e
          - i-0a6b63f03c28c1336
          - i-019d6e26b39617852
          - i-00ca906185f13e772
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1

      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean
  push:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'

env:
  TF_VERSION: "1.5.7"
  PYTHON_VERSION: "3.9"
  # Optional: Set this to use an existing S3 bucket instead of creating a new one
  # EXISTING_S3_BUCKET: ""

jobs:
  validate:
    name: Validate Terraform Configuration
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check environment
        run: |
          echo "=== Environment Check ==="
          echo "User: $(whoami)"
          echo "EUID: $EUID"
          echo "Distribution: $(cat /etc/os-release | grep PRETTY_NAME || echo 'Unknown')"
          echo "Available commands:"
          command -v curl >/dev/null 2>&1 && echo "✓ curl available" || echo "✗ curl not found"
          command -v unzip >/dev/null 2>&1 && echo "✓ unzip available" || echo "✗ unzip not found"
          command -v python3 >/dev/null 2>&1 && echo "✓ python3 available" || echo "✗ python3 not found"
          command -v pip3 >/dev/null 2>&1 && echo "✓ pip3 available" || echo "✗ pip3 not found"
          command -v jq >/dev/null 2>&1 && echo "✓ jq available" || echo "✗ jq not found"
          echo "================================"
        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq || {
            echo "⚠️  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "✅ Python3 is available, continuing..."
            else
              echo "❌ Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Format Check and Fix
        run: |
          cd terraform
          echo "Checking Terraform formatting with version $(terraform version | head -n1)..."
          
          # Show current file structure
          echo "Current Terraform files:"
          ls -la *.tf
          
          # First, try to format the files automatically
          echo "Auto-formatting Terraform files..."
          terraform fmt -recursive || {
            echo "⚠️  Auto-formatting failed, but continuing..."
          }
          
          # Then check if formatting is correct
          echo "Checking formatting compliance..."
          if terraform fmt -check -recursive; then
            echo "✅ Terraform formatting is correct"
          else
            echo "⚠️  Terraform formatting issues found, but continuing..."
            echo "This is a warning, not a critical error."
            echo "Files have been auto-formatted for the next run."
            echo "Note: This warning will be resolved in subsequent runs."
          fi
        continue-on-error: true
          
      - name: Terraform Init (Local Backend for Testing)
        run: |
          cd terraform
          echo "=== Initializing Terraform with Local Backend ==="
          echo "Note: S3 backend is disabled for testing SSH key management functionality"
          
          # Initialize Terraform without S3 backend
          echo "Running terraform init..."
          if terraform init 2>&1; then
            echo "✅ Terraform initialized successfully with local backend"
            echo "State will be stored locally for testing"
          else
            echo "❌ Terraform initialization failed"
            echo "This might be due to:"
            echo "1. Network connectivity issues"
            echo "2. Provider download problems"
            echo "3. Configuration syntax errors"
            echo ""
            echo "Attempting to get more detailed error information..."
            terraform init 2>&1 || {
              echo "❌ Terraform initialization failed with detailed output above"
              exit 1
            }
          fi
          
          # Verify configuration
          echo "Terraform version:"
          terraform version
          echo "Terraform providers:"
          terraform providers
          
      - name: Terraform Validate
        run: |
          cd terraform
          echo "Validating Terraform configuration..."
          
          # Show Terraform version and configuration details
          echo "Terraform version:"
          terraform version
          
          echo "Current directory: $(pwd)"
          echo "Terraform files present:"
          ls -la *.tf
          
          echo "Terraform providers:"
          terraform providers
          
          # Try validation with detailed output
          echo "Running terraform validate..."
          
          # First try with standard output to see any warnings
          echo "Standard validation output:"
          terraform validate 2>&1 && {
            echo "✅ Terraform configuration is valid"
          } || {
            echo "❌ Terraform validation failed"
            echo "Attempting to get more detailed error information..."
            
            # Try to get specific validation errors with more verbose output
            echo "Detailed validation attempt:"
            terraform validate -detailed-exitcode 2>&1 || {
              echo "❌ Terraform validation failed with detailed output above"
              echo "Common causes:"
              echo "1. Syntax errors in .tf files"
              echo "2. Provider version incompatibilities"
              echo "3. Variable definition issues"
              echo "4. Resource reference problems"
              echo "5. Missing required providers"
              echo ""
              echo "Please check the error output above for specific issues"
              exit 1
            }
          }
          
      - name: Validate Users YAML
        run: |
          python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              print(f'Found {len(data[\"users\"])} users in configuration')
              for user in data['users']:
                  if not all(k in user for k in ['username', 'email']):
                      raise ValueError(f'User {user} missing required fields')
                  print(f'  - {user[\"username\"]} ({user[\"email\"]})')
          "

  provision-users:
    name: Provision Users on EC2 Instances
    needs: validate
    runs-on: docker
    if: github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        

        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq awscli openssh-client || {
            echo "⚠️  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            command -v aws >/dev/null 2>&1 || echo "aws CLI not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "✅ Python3 is available, continuing..."
            else
              echo "❌ Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          set -e
          # Validate required secrets
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "❌ Required secret 'aws_ec2_creation_role' is not set"
            echo "Please add this secret to your repository settings"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: ${{ vars.GITHUBACTIONSAPPSESSION || 3600 }}
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          set -e
          echo "=== AWS Credentials Verification ==="
          
          # Test AWS credentials with detailed error handling
          echo "Testing AWS credentials..."
          aws sts get-caller-identity || {
            echo "❌ AWS credentials are invalid or expired"
            echo "Possible issues:"
            echo "1. OIDC role configuration is incorrect"
            echo "2. Role permissions are insufficient"
            echo "3. Wrong AWS region"
            echo "4. Role name is incorrect (tried: ${{ secrets.aws_ec2_creation_role }})"
            echo "5. Account ID is incorrect (tried: ${{ inputs.aws_account_id }})"
            echo ""
            echo "Please verify:"
            echo "- The role exists in your AWS account"
            echo "- The role has proper permissions for EC2 access"
            echo "- Set aws_ec2_creation_role secret if role name is different"
            echo "- Verify the role ARN: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}"
            exit 1
          }
          
          echo "✅ AWS credentials verified successfully"
          echo "Caller Identity:"
          aws sts get-caller-identity
          
      - name: Check Required AWS Permissions
        run: |
          set -e
          echo "=== Checking Required AWS Permissions ==="
          
          # Test S3 permissions
          echo "Testing S3 permissions..."
          
          # Create a test bucket name
          TEST_BUCKET="permission-test-$(date +%Y%m%d-%H%M%S)"
          
          # Test bucket creation permission
          if aws s3 mb s3://$TEST_BUCKET --region ${{ inputs.aws_region }} 2>&1; then
            echo "✅ S3 bucket creation permission: OK"
            
            # Test object upload permission
            echo "test content" > /tmp/test_file
            if aws s3 cp /tmp/test_file s3://$TEST_BUCKET/test_file 2>&1; then
              echo "✅ S3 object upload permission: OK"
              
              # Test object listing permission
              if aws s3 ls s3://$TEST_BUCKET/ 2>&1; then
                echo "✅ S3 object listing permission: OK"
                
                # Test object download permission
                if aws s3 cp s3://$TEST_BUCKET/test_file /tmp/test_download 2>&1; then
                  echo "✅ S3 object download permission: OK"
                else
                  echo "❌ S3 object download permission: FAILED"
                fi
              else
                echo "❌ S3 object listing permission: FAILED"
              fi
            else
              echo "❌ S3 object upload permission: FAILED"
            fi
            
            # Clean up test bucket
            aws s3 rb s3://$TEST_BUCKET --force 2>&1 || true
            rm -f /tmp/test_file /tmp/test_download
          else
            echo "❌ S3 bucket creation permission: FAILED"
            echo "The role needs the following S3 permissions:"
            echo "- s3:CreateBucket"
            echo "- s3:PutObject"
            echo "- s3:GetObject"
            echo "- s3:ListBucket"
            echo ""
            echo "Please add these permissions to the role: ${{ secrets.aws_ec2_creation_role }}"
          fi
          
          echo "=== End Permission Check ==="
          
      - name: Generate and Upload SSH Keys to S3
        run: |
          set -e
          echo "=== Generating SSH Keys and Uploading to S3 ==="
          
          # Set region variable
          REGION="${{ inputs.aws_region }}"
          
          # Check if using existing bucket or creating new one
          if [ -n "${{ env.EXISTING_S3_BUCKET }}" ]; then
            BUCKET_NAME="${{ env.EXISTING_S3_BUCKET }}"
            echo "Using existing S3 bucket: $BUCKET_NAME"
            
            # Verify existing bucket is accessible
            if aws s3 ls s3://$BUCKET_NAME >/dev/null 2>&1; then
              echo "✅ Existing bucket $BUCKET_NAME is accessible"
            else
              echo "❌ Cannot access existing bucket $BUCKET_NAME"
              echo "Please check:"
              echo "1. Bucket name is correct"
              echo "2. Role has s3:ListBucket permission"
              echo "3. Bucket exists in region ${{ inputs.aws_region }}"
              exit 1
            fi
          else
            # Use a more unique bucket name to avoid conflicts
            BUCKET_NAME="ec2-user-provisioning-$(date +%Y%m%d-%H%M%S)"
            echo "Using unique bucket name: $BUCKET_NAME"
            
            # Check AWS permissions first
            echo "Checking AWS permissions..."
            aws sts get-caller-identity || {
              echo "❌ Cannot get caller identity - AWS credentials issue"
              exit 1
            }
            
            # Try to create S3 bucket with better error handling
            echo "Creating S3 bucket: $BUCKET_NAME"
            if aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} 2>&1; then
              echo "✅ S3 bucket created successfully: $BUCKET_NAME"
            else
              echo "⚠️  S3 bucket creation failed, checking if it already exists..."
              if aws s3 ls s3://$BUCKET_NAME >/dev/null 2>&1; then
                echo "✅ S3 bucket $BUCKET_NAME already exists"
              else
                echo "❌ Failed to create or access S3 bucket"
                echo "This might be due to:"
                echo "1. Insufficient S3 permissions (need s3:CreateBucket)"
                echo "2. Bucket name already exists globally"
                echo "3. Invalid bucket name format"
                echo ""
                echo "Trying alternative bucket name..."
                
                # Try alternative bucket name
                BUCKET_NAME="ec2-user-provisioning-test-$(date +%Y%m%d)"
                echo "Trying alternative bucket: $BUCKET_NAME"
                
                if aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} 2>&1; then
                  echo "✅ Alternative S3 bucket created: $BUCKET_NAME"
                else
                  echo "❌ All bucket creation attempts failed"
                  echo "Please check AWS permissions or use existing bucket"
                  echo ""
                  echo "To use an existing bucket, set the EXISTING_S3_BUCKET environment variable"
                  exit 1
                fi
              fi
            fi
          fi
          
          # Enable versioning on S3 bucket
          echo "Enabling versioning on S3 bucket..."
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled \
            --region ${{ inputs.aws_region }} || {
            echo "⚠️  Failed to enable versioning (bucket might have restrictions)"
          }
          
          # Create temporary directory for keys
          mkdir -p /tmp/ssh_keys
          
          # Check disk space and permissions
          echo "Checking disk space and permissions..."
          df -h /tmp
          ls -la /tmp/ssh_keys
          
          # Ensure proper permissions
          chmod 755 /tmp/ssh_keys
          
          # Generate SSH keys for each user
          echo "Generating SSH keys for users..."
          
          # Check if ssh-keygen is available
          if ! command -v ssh-keygen >/dev/null 2>&1; then
            echo "❌ ssh-keygen command not found"
            echo "Installing openssh-client..."
            if [ "$EUID" -eq 0 ]; then
              apt-get update && apt-get install -y openssh-client
            else
              sudo apt-get update && sudo apt-get install -y openssh-client
            fi
          fi
          
          for user in alice bob charlie diana eve; do
            echo "Generating keys for user: $user"
            
            # Generate RSA 4096-bit key pair with better error handling
            if ssh-keygen -t rsa -b 4096 \
              -f /tmp/ssh_keys/${user}_key \
              -N "" \
              -C "${user}@ec2-provisioning-$(date +%Y%m%d-%H%M%S)" 2>&1; then
              
              # Rename files for clarity
              mv /tmp/ssh_keys/${user}_key /tmp/ssh_keys/${user}_private_key
              mv /tmp/ssh_keys/${user}_key.pub /tmp/ssh_keys/${user}_public_key
              
              # Verify key generation
              if [ -f "/tmp/ssh_keys/${user}_private_key" ] && [ -f "/tmp/ssh_keys/${user}_public_key" ]; then
                echo "✅ Generated keys for $user"
                
                # Show key fingerprint for verification
                echo "Key fingerprint for $user:"
                ssh-keygen -l -f /tmp/ssh_keys/${user}_public_key
              else
                echo "❌ Failed to generate keys for $user"
                exit 1
              fi
            else
              echo "❌ Failed to generate SSH keys for $user"
              echo "This might be due to:"
              echo "1. Insufficient disk space"
              echo "2. Permission issues in /tmp"
              echo "3. ssh-keygen command failure"
              exit 1
            fi
          done
          
          # Upload keys to S3 with encryption
          echo "Uploading SSH keys to S3..."
          for user in alice bob charlie diana eve; do
            echo "Uploading keys for user: $user"
            
            # Check if keys already exist (conditional upload)
            if aws s3 ls s3://$BUCKET_NAME/keys/${user}_private_key >/dev/null 2>&1; then
              echo "⚠️  Keys for $user already exist in S3, backing up old keys..."
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_private_key \
                s3://$BUCKET_NAME/keys/backup/$(date +%Y%m%d-%H%M%S)_${user}_private_key || true
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_public_key \
                s3://$BUCKET_NAME/keys/backup/$(date +%Y%m%d-%H%M%S)_${user}_public_key || true
            fi
            
            # Upload private key with server-side encryption
            echo "Uploading private key for $user..."
            if aws s3 cp /tmp/ssh_keys/${user}_private_key \
              s3://$BUCKET_NAME/keys/${user}_private_key \
              --sse AES256 \
              --metadata "user=$user,generated-by=github-actions,workflow-run=${{ github.run_id }}" 2>&1; then
              echo "✅ Private key uploaded for $user"
            else
              echo "❌ Failed to upload private key for $user"
              echo "This might be due to:"
              echo "1. Insufficient S3 permissions (need s3:PutObject)"
              echo "2. S3 bucket access issues"
              echo "3. Network connectivity problems"
              exit 1
            fi
            
            # Upload public key
            echo "Uploading public key for $user..."
            if aws s3 cp /tmp/ssh_keys/${user}_public_key \
              s3://$BUCKET_NAME/keys/${user}_public_key \
              --sse AES256 \
              --metadata "user=$user,generated-by=github-actions,workflow-run=${{ github.run_id }}" 2>&1; then
              echo "✅ Public key uploaded for $user"
            else
              echo "❌ Failed to upload public key for $user"
              exit 1
            fi
            
            # Verify upload
            if aws s3 ls s3://$BUCKET_NAME/keys/${user}_private_key >/dev/null 2>&1 && \
               aws s3 ls s3://$BUCKET_NAME/keys/${user}_public_key >/dev/null 2>&1; then
              echo "✅ Successfully uploaded keys for $user"
            else
              echo "❌ Failed to verify upload for $user"
              exit 1
            fi
          done
          
          # Create metadata file
          cat > /tmp/key_metadata.json << EOF
          {
            "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "generated_by": "github-actions",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "users": ["alice", "bob", "charlie", "diana", "eve"],
            "key_algorithm": "RSA",
            "key_size": 4096,
            "bucket": "$BUCKET_NAME"
          }
          EOF
          
          # Upload metadata
          aws s3 cp /tmp/key_metadata.json \
            s3://$BUCKET_NAME/metadata/key-generation-$(date +%Y%m%d-%H%M%S).json \
            --sse AES256
          
          echo "✅ SSH key generation and S3 upload completed successfully"
          echo "Keys stored in bucket: s3://$BUCKET_NAME/keys/"
          
          # Store bucket name for Terraform to use
          echo "ssh_keys_bucket_name=$BUCKET_NAME" >> $GITHUB_ENV
          echo "✅ Bucket name stored for Terraform: $BUCKET_NAME"
          
          # Download public keys and store content for Terraform
          echo "Downloading public keys for Terraform variables..."
          mkdir -p /tmp/terraform_keys
          
          for user in alice bob charlie diana eve; do
            echo "Downloading public key for $user..."
            if aws s3 cp s3://$BUCKET_NAME/keys/${user}_public_key /tmp/terraform_keys/${user}_public_key; then
              # Read the key content and escape it for Terraform
              KEY_CONTENT=$(cat /tmp/terraform_keys/${user}_public_key | tr -d '\n' | sed 's/"/\\"/g')
              echo "user_public_keys_${user}=\"$KEY_CONTENT\"" >> $GITHUB_ENV
              echo "✅ Public key downloaded for $user"
            else
              echo "❌ Failed to download public key for $user"
              exit 1
            fi
          done
          
          # Note: SSH keys are downloaded and will be used by Terraform
          
          # Clean up temporary files
          rm -rf /tmp/ssh_keys /tmp/key_metadata.json
          echo "✅ Temporary files cleaned up"
          
      - name: Debug AWS Environment
        run: |
          set -e
          echo "=== AWS Environment Debug ==="
          echo "AWS Region: ${{ inputs.aws_region }}"
          echo "AWS Account ID: ${{ inputs.aws_account_id }}"
          echo "Role Name: ${{ secrets.aws_ec2_creation_role }}"
          echo "Full Role ARN: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}"
          
          # Test AWS CLI version and configuration
          echo "AWS CLI Version:"
          aws --version
          
          # Test basic AWS permissions
          echo "Testing AWS permissions..."
          echo "1. Testing EC2 Describe Instances permission..."
          aws ec2 describe-instances --region ${{ inputs.aws_region }} --max-items 1 --query 'Reservations[0].Instances[0].InstanceId' --output text || {
            echo "❌ Cannot describe EC2 instances - permission issue"
            echo "The role needs ec2:DescribeInstances permission"
          }
          
          echo "2. Testing IAM Get Role permission..."
          aws iam get-role --role-name ${{ secrets.aws_ec2_creation_role }} || {
            echo "❌ Cannot get IAM role - permission issue"
            echo "The role needs iam:GetRole permission"
          }
          
          echo "3. Testing STS Get Caller Identity..."
          aws sts get-caller-identity || {
            echo "❌ Cannot get caller identity"
          }
          
          echo "=== End AWS Environment Debug ==="
          
      - name: Check SSH Key Availability
        run: |
          set -e
          echo "=== SSH Key Availability Check ==="
          
          # Check if SSH private key secret is set
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "❌ SSH private key secret 'EC2_SSH_PRIVATE_KEY' is not set"
            echo "This is required for connecting to EC2 instances"
            echo ""
            echo "To fix this:"
            echo "1. Add the EC2_SSH_PRIVATE_KEY secret to your repository"
            echo "2. The value should be the private key content (not the file path)"
            echo "3. This key must match the key pair used to launch the EC2 instances"
            echo ""
            echo "Alternative: Consider using AWS Systems Manager (SSM) instead of SSH"
            echo "This would eliminate the need for SSH keys entirely"
            exit 1
          else
            echo "✅ SSH private key secret is set"
            echo "Key length: ${#EC2_SSH_PRIVATE_KEY} characters"
            
            # Test if the key looks like a valid SSH private key
            if [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == *"-----BEGIN"* ]] && [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == *"-----END"* ]]; then
              echo "✅ SSH key format appears valid"
            else
              echo "⚠️  SSH key format may be invalid - should contain BEGIN/END markers"
            fi
          fi
          
          echo "=== End SSH Key Check ==="
          
      - name: Create SSH Key File
        run: |
          set -e
          echo "=== Creating SSH Key File ==="
          
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the SSH key from secret to file
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
          chmod 600 ~/.ssh/ec2-provisioning-key
          
          echo "✅ SSH key file created at ~/.ssh/ec2-provisioning-key"
          echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
          
          # Verify the key file exists and has correct permissions
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "✅ SSH key file exists and is readable"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
          else
            echo "❌ SSH key file was not created successfully"
            exit 1
          fi
          
          echo "=== End SSH Key File Creation ==="
          
      - name: Validate Instance ID
        run: |
          set -e
          echo "=== Instance ID Validation ==="
          
          INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
          echo "Selected instance ID: $INSTANCE_ID"
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "❌ No instance ID selected"
            exit 1
          fi
          
          # Check instance ID format
          echo "Validating instance ID: $INSTANCE_ID"
          
          # Check format
          if [[ ! "$INSTANCE_ID" =~ ^i-[a-f0-9]{8,17}$ ]]; then
            echo "❌ Invalid instance ID format: $INSTANCE_ID"
            echo "Instance IDs must be in format: i-xxxxxxxxxxxxxxxxx"
            exit 1
          fi
          
          # Check if instance exists in AWS and get details
          echo "Checking if instance $INSTANCE_ID exists in AWS..."
          if aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region ${{ inputs.aws_region }} --query 'Reservations[0].Instances[0]' --output json 2>/dev/null; then
            INSTANCE_INFO=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region ${{ inputs.aws_region }} --query 'Reservations[0].Instances[0]' --output json)
            INSTANCE_STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')
            PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress // empty')
            
            echo "✅ Instance $INSTANCE_ID exists and is in state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "❌ Instance $INSTANCE_ID is not running (state: $INSTANCE_STATE)"
              echo "The instance must be running for user provisioning to work"
              exit 1
            fi
            
            if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "null" ]; then
              echo "⚠️  Instance $INSTANCE_ID does not have a public IP address"
              echo "Will use private IP for SSH connection (assuming same network)"
            else
              echo "✅ Instance $INSTANCE_ID has public IP: $PUBLIC_IP"
            fi
            
            # Check for private IP
            PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.PrivateIpAddress // empty')
            if [ -z "$PRIVATE_IP" ] || [ "$PRIVATE_IP" = "null" ]; then
              echo "❌ Instance $INSTANCE_ID does not have a private IP address"
              echo "Cannot connect to instance without IP address"
              exit 1
            else
              echo "✅ Instance $INSTANCE_ID has private IP: $PRIVATE_IP"
            fi
          else
            echo "❌ Instance $INSTANCE_ID does not exist in AWS region ${{ inputs.aws_region }}"
            echo "Please verify:"
            echo "1. The instance ID is correct"
            echo "2. The instance exists in the specified region (${{ inputs.aws_region }})"
            echo "3. You have permission to describe this instance"
            exit 1
          fi
          
          echo "=== End Instance ID Validation ==="
          
      - name: Check Terraform Configuration
        run: |
          set -e
          echo "=== Terraform Configuration Check ==="
          
          cd terraform
          
          # Check if required files exist
          echo "Checking Terraform files..."
          ls -la *.tf
          
          # Check if variables.tf has required variables
          if grep -q "instance_ids" variables.tf; then
            echo "✅ instance_ids variable is defined"
          else
            echo "❌ instance_ids variable is not defined in variables.tf"
          fi
          
          if grep -q "aws_region" variables.tf; then
            echo "✅ aws_region variable is defined"
          else
            echo "❌ aws_region variable is not defined in variables.tf"
          fi
          
          # Check if main.tf references the SSH key path
          if grep -q "ssh_private_key_path" main.tf; then
            echo "✅ SSH key path is referenced in main.tf"
          else
            echo "❌ SSH key path is not referenced in main.tf"
          fi
          
          echo "=== End Terraform Configuration Check ==="
          
      - name: Parse Instance ID
        id: parse-instances
        run: |
          set -e
          # Check if this is a manual workflow dispatch with instance ID
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.instance_ids }}" ]; then
            INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
            echo "Using selected instance ID: $INSTANCE_ID"
          else
            # For automatic triggers (push/PR), use a default or placeholder
            # You can modify this to use a default instance ID or skip the job
            echo "No instance ID selected for automatic trigger"
            echo "This workflow requires manual trigger with instance ID selection"
            echo "Please run this workflow manually and select an instance ID"
            exit 1
          fi
          
          # Validate instance ID format
          if [[ ! "$INSTANCE_ID" =~ ^i-[a-f0-9]{8,17}$ ]]; then
            echo "❌ Invalid instance ID format: $INSTANCE_ID"
            echo "Instance IDs must be in format: i-xxxxxxxxxxxxxxxxx"
            exit 1
          fi
          
          # Convert single instance ID to Terraform list format
          echo "Converting instance ID to Terraform list format..."
          
          # Note: terraform.tfvars will be created later with all required variables
          echo "Instance ID validated: $INSTANCE_ID"
          
      - name: Create Keys Directory
        run: |
          cd terraform
          mkdir -p keys
          
      - name: Verify SSH Key Before Terraform
        run: |
          set -e
          echo "=== Pre-Terraform SSH Key Verification ==="
          
          # Check if SSH key file exists
          if [ ! -f ~/.ssh/ec2-provisioning-key ]; then
            echo "❌ SSH key file missing before Terraform execution"
            echo "Creating SSH key file from secret..."
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
            chmod 600 ~/.ssh/ec2-provisioning-key
          fi
          
          # Verify the file exists and has correct permissions
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "✅ SSH key file verified: ~/.ssh/ec2-provisioning-key"
            echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
          else
            echo "❌ SSH key file still missing after creation attempt"
            exit 1
          fi
          
          echo "=== End SSH Key Verification ==="
          
      - name: Setup Terraform S3 Backend
        run: |
          set -e
          echo "=== Setting up Terraform S3 Backend ==="
          
          # Use the same bucket as SSH keys for consistency
          BUCKET_NAME="${{ env.ssh_keys_bucket_name }}"
          DYNAMODB_TABLE="terraform-state-lock"
          REGION="${{ inputs.aws_region }}"
          
          echo "Using SSH keys bucket for Terraform state: $BUCKET_NAME"
          
          # Create DynamoDB table for state locking
          echo "Creating DynamoDB table: $DYNAMODB_TABLE"
          aws dynamodb create-table \
            --table-name $DYNAMODB_TABLE \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region $REGION || {
            echo "ℹ️  DynamoDB table might already exist, checking..."
            if aws dynamodb describe-table --table-name $DYNAMODB_TABLE --region $REGION >/dev/null 2>&1; then
              echo "✅ DynamoDB table $DYNAMODB_TABLE already exists"
            else
              echo "❌ Failed to create or access DynamoDB table"
              exit 1
            fi
          }
          
          # Wait for DynamoDB table to be active
          echo "Waiting for DynamoDB table to be active..."
          aws dynamodb wait table-exists --table-name $DYNAMODB_TABLE --region $REGION || {
            echo "⚠️  Timeout waiting for table, but continuing..."
          }
          
          echo "✅ Terraform S3 backend infrastructure ready"
          echo "State bucket: s3://$BUCKET_NAME"
          echo "Lock table: $DYNAMODB_TABLE"
          
      - name: Terraform Init (Local Backend for Testing)
        run: |
          cd terraform
          echo "=== Terraform Initialization with Local Backend ==="
          echo "Current directory: $(pwd)"
          echo "Terraform files present:"
          ls -la *.tf
          
          echo "Backend configuration (commented out for testing):"
          cat backend.tf
          
          echo "Initializing Terraform with local backend..."
          terraform init || {
            echo "❌ Terraform initialization failed"
            echo "This might be due to:"
            echo "1. Network connectivity issues"
            echo "2. Provider download problems"
            echo "3. Configuration syntax errors"
            echo "4. AWS permissions issues"
            exit 1
          }
          echo "✅ Terraform initialized successfully with local backend"
          echo "State will be stored locally in terraform.tfstate"
          
      - name: Create Terraform Variables File
        run: |
          set -e
          cd terraform
          echo "=== Creating Terraform Variables File ==="
          
          # Create terraform.tfvars with instance IDs
          echo "instance_ids = [\"${{ github.event.inputs.instance_ids }}\"]" > terraform.tfvars
          echo "aws_region = \"${{ inputs.aws_region }}\"" >> terraform.tfvars
          echo "dry_run = ${{ github.event.inputs.dry_run }}" >> terraform.tfvars
          echo "ssh_keys_bucket_name = \"${{ env.ssh_keys_bucket_name }}\"" >> terraform.tfvars
          
          echo "✅ terraform.tfvars created"
          echo "File contents:"
          cat terraform.tfvars
          
      - name: Terraform Plan
        id: plan
        timeout-minutes: 10
        run: |
          set -e
          cd terraform
          echo "=== Terraform Plan Execution ==="
          
          # Show current terraform.tfvars content
          echo "Current terraform.tfvars content:"
          if [ -f "terraform.tfvars" ]; then
            cat terraform.tfvars
          else
            echo "❌ terraform.tfvars file not found"
            exit 1
          fi
          
          # Show variables that will be used
          echo "Variables to be used:"
          echo "- aws_region: ${{ inputs.aws_region }}"
          echo "- dry_run: ${{ github.event.inputs.dry_run }}"
          echo "- instance_ids: (from terraform.tfvars)"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode - no actual changes will be made"
            terraform plan \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=true" \
              -var="ssh_keys_bucket_name=${{ env.ssh_keys_bucket_name }}" \
              -detailed-exitcode || {
              echo "❌ Terraform plan failed"
              echo "Common causes:"
              echo "1. SSH private key file missing (check EC2_SSH_PRIVATE_KEY secret)"
              echo "2. EC2 instance not found (check instance ID and region)"
              echo "3. Insufficient AWS permissions"
              echo "4. Terraform configuration errors"
              echo "5. Network connectivity issues"
              exit 1
            }
          else
            terraform plan \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=false" \
              -var="ssh_keys_bucket_name=${{ env.ssh_keys_bucket_name }}" \
              -out=tfplan || {
              echo "❌ Terraform plan failed"
              echo "Common causes:"
              echo "1. SSH private key file missing (check EC2_SSH_PRIVATE_KEY secret)"
              echo "2. EC2 instance not found (check instance ID and region)"
              echo "3. Insufficient AWS permissions"
              echo "4. Terraform configuration errors"
              echo "5. Network connectivity issues"
              exit 1
            }
          fi
          
          echo "✅ Terraform plan completed successfully"
        continue-on-error: true
        
      - name: Show Terraform Plan
        run: |
          cd terraform
          echo "=== Terraform Plan Details ==="
          if [ -f "tfplan" ]; then
            echo "Plan file exists, showing details..."
            terraform show tfplan || {
              echo "❌ Failed to show terraform plan"
              echo "This might indicate a corrupted plan file"
            }
          else
            echo "No plan file found (dry run mode or no changes)"
            echo "This could mean:"
            echo "1. No changes are needed"
            echo "2. Plan failed and didn't create a plan file"
            echo "3. Running in dry-run mode"
          fi
          
      - name: Debug Terraform State
        run: |
          cd terraform
          echo "=== Terraform State Debug ==="
          
          # Check if state file exists
          if [ -f ".terraform/terraform.tfstate" ]; then
            echo "✅ Terraform state file exists"
            echo "State file size: $(stat -c%s .terraform/terraform.tfstate) bytes"
          else
            echo "⚠️  No terraform state file found"
          fi
          
          # Show current state
          echo "Current Terraform state:"
          terraform show || {
            echo "❌ Failed to show terraform state"
          }
          
          echo "=== End Terraform State Debug ==="
          
      - name: Check SSH Key File Issues
        run: |
          set -e
          echo "=== SSH Key File Check ==="
          
          cd terraform
          
          # Check if the SSH key file path is being used correctly
          echo "Checking SSH key file references in Terraform..."
          
          # Look for SSH key path references in main.tf
          if grep -q "ssh_private_key_path" main.tf; then
            echo "✅ SSH key path variable is referenced in main.tf"
            
            # Check what the default path is
            SSH_PATH=$(grep -A1 -B1 "ssh_private_key_path" main.tf || echo "Not found")
            echo "SSH key path configuration:"
            echo "$SSH_PATH"
          else
            echo "❌ SSH key path not found in main.tf"
          fi
          
          # Check if the SSH key file exists at the expected location
          EXPECTED_PATH="~/.ssh/ec2-provisioning-key"
          echo "Expected SSH key path: $EXPECTED_PATH"
          
          # Check if the SSH key file exists
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "✅ SSH key file exists at ~/.ssh/ec2-provisioning-key"
            echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
            
            # Show first few lines of the key (safely)
            echo "Key file content preview:"
            head -3 ~/.ssh/ec2-provisioning-key | sed 's/.*/***/'
          else
            echo "❌ SSH key file does not exist at ~/.ssh/ec2-provisioning-key"
            echo "This means the 'Create SSH Key File' step failed or didn't run"
            
            # Try to create it again
            echo "Attempting to create SSH key file again..."
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
            chmod 600 ~/.ssh/ec2-provisioning-key
            
            if [ -f ~/.ssh/ec2-provisioning-key ]; then
              echo "✅ SSH key file created successfully"
              echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            else
              echo "❌ Failed to create SSH key file"
              exit 1
            fi
          fi
          
          echo "=== End SSH Key File Check ==="
          
      - name: Check Output Format Issues
        run: |
          set -e
          echo "=== Output Format Check ==="
          
          cd terraform
          
          # Check the outputs.tf file for potential issues
          echo "Checking outputs.tf for format issues..."
          
          if [ -f "outputs.tf" ]; then
            echo "✅ outputs.tf file exists"
            
            # Check for the specific output that was causing issues
            if grep -q "user_private_keys" outputs.tf; then
              echo "Found user_private_keys output, checking format..."
              
              # Show the output definition
              grep -A10 "user_private_keys" outputs.tf || echo "Output definition not found"
              
              echo "⚠️  Note: The 'Invalid index' error suggests the output format may need adjustment"
              echo "This typically happens when trying to access a map with numeric keys"
            else
              echo "user_private_keys output not found in outputs.tf"
            fi
          else
            echo "❌ outputs.tf file not found"
          fi
          
          echo "=== End Output Format Check ==="
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true' && github.event.inputs.dry_run != true
        timeout-minutes: 15
        run: |
          set -e
          cd terraform
          echo "=== Terraform Apply Execution ==="
          
          # Check if plan file exists
          if [ -f "tfplan" ]; then
            echo "✅ Plan file exists, proceeding with apply..."
            echo "Plan file size: $(stat -c%s tfplan) bytes"
            
            # Show what will be applied
            echo "Resources to be applied:"
            terraform show tfplan | grep -E "^[+-]" || echo "No changes detected"
            
            # Apply the plan
            terraform apply -auto-approve tfplan || {
              echo "❌ Terraform apply failed"
              echo "Common causes:"
              echo "1. SSH connection failed to EC2 instances"
              echo "2. EC2 instances are not running"
              echo "3. SSH key authentication failed"
              echo "4. Network connectivity issues"
              echo "5. Insufficient permissions on EC2 instances"
              echo ""
              echo "Debugging steps:"
              echo "1. Verify EC2 instances are running"
              echo "2. Check SSH key is correct"
              echo "3. Verify security groups allow SSH access"
              echo "4. Check instance user permissions"
              exit 1
            }
            
            echo "✅ Terraform apply completed successfully"
          else
            echo "❌ No plan file found - skipping apply"
            echo "This could mean:"
            echo "1. Plan step failed"
            echo "2. No changes are needed"
            echo "3. Plan file was not created"
            exit 1
          fi
          
          echo "=== End Terraform Apply ==="
          
      - name: Terraform Output
        run: |
          cd terraform
          echo "=== Terraform Output Generation ==="
          
          # Try to generate outputs with error handling
          echo "Generating Terraform outputs..."
          terraform output -json > terraform_output.json || {
            echo "❌ Failed to generate Terraform outputs"
            echo "This might be due to:"
            echo "1. Output format errors (Invalid index errors)"
            echo "2. Resources not created successfully"
            echo "3. State file issues"
            echo ""
            echo "Attempting to show outputs in text format..."
            terraform output || {
              echo "❌ Also failed to show outputs in text format"
              echo "This suggests the outputs.tf file may have format issues"
            }
            exit 1
          }
          
          echo "✅ Terraform outputs saved to terraform_output.json"
          echo "Output file size: $(stat -c%s terraform_output.json) bytes"
          
          # Show a summary of the outputs
          echo "Output summary:"
          terraform output -json | jq 'keys' || {
            echo "❌ Failed to parse outputs with jq"
            echo "Raw output content:"
            cat terraform_output.json
          }
          
          echo "=== End Terraform Output ==="
          
      - name: Download SSH Keys for Email Distribution
        run: |
          set -e
          echo "=== Downloading SSH Keys from S3 for Email Distribution ==="
          
          BUCKET_NAME="${{ env.ssh_keys_bucket_name }}"
          
          # Create directory for downloaded keys
          mkdir -p user_keys_for_email
          
          # Download keys for each user
          for user in alice bob charlie diana eve; do
            echo "Downloading keys for user: $user"
            
            # Download private key for emailing
            if aws s3 cp s3://$BUCKET_NAME/keys/${user}_private_key \
                 user_keys_for_email/${user}_private_key.pem; then
              echo "✅ Downloaded private key for $user"
            else
              echo "❌ Failed to download private key for $user"
              exit 1
            fi
            
            # Download public key for reference
            if aws s3 cp s3://$BUCKET_NAME/keys/${user}_public_key \
                 user_keys_for_email/${user}_public_key.pub; then
              echo "✅ Downloaded public key for $user"
            else
              echo "❌ Failed to download public key for $user"
              exit 1
            fi
            
            # Verify key file integrity
            if ssh-keygen -l -f user_keys_for_email/${user}_public_key.pub >/dev/null 2>&1; then
              echo "✅ Key integrity verified for $user"
            else
              echo "❌ Key integrity check failed for $user"
              exit 1
            fi
          done
          
          # Create distribution package with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          tar -czf user-ssh-keys-$TIMESTAMP.tar.gz user_keys_for_email/
          
          # Upload distribution package back to S3
          aws s3 cp user-ssh-keys-$TIMESTAMP.tar.gz \
            s3://$BUCKET_NAME/distributions/ \
            --sse AES256
          
          # Create latest symlink
          aws s3 cp user-ssh-keys-$TIMESTAMP.tar.gz \
            s3://$BUCKET_NAME/distributions/user-ssh-keys-latest.tar.gz \
            --sse AES256
          
          echo "✅ SSH keys downloaded and packaged for email distribution"
          echo "Package created: user-ssh-keys-$TIMESTAMP.tar.gz"
          echo "Distribution package uploaded to: s3://$BUCKET_NAME/distributions/"
          
          # Display package contents for verification
          echo "Package contents:"
          tar -tzf user-ssh-keys-$TIMESTAMP.tar.gz
          
      - name: Show Provisioning Summary
        run: |
          cd terraform
          echo "=== PROVISIONING SUMMARY ==="
          
          # Try to show provisioning summary with error handling
          terraform output provisioning_summary || {
            echo "❌ Failed to show provisioning_summary output"
            echo "This might be due to output format issues or missing output"
          }
          
          echo ""
          echo "=== INSTANCES PROVISIONED ==="
          terraform output provisioned_instances || {
            echo "❌ Failed to show provisioned_instances output"
            echo "This might be due to output format issues or missing output"
          }
          
          echo ""
          echo "=== ALL AVAILABLE OUTPUTS ==="
          terraform output || {
            echo "❌ Failed to show any outputs"
            echo "This suggests the outputs.tf file may have issues"
          }
          
          echo "=== END PROVISIONING SUMMARY ==="
          
      - name: Test SSH Key Authentication
        run: |
          set -e
          echo "=== Testing SSH Key Authentication ==="
          
          # Get instance information from Terraform
          cd terraform
          INSTANCE_INFO=$(terraform output -json provisioned_instances)
          echo "Instance information: $INSTANCE_INFO"
          
          # Extract the first instance ID and IP
          FIRST_INSTANCE_ID=$(echo "$INSTANCE_INFO" | jq -r 'keys[0]')
          INSTANCE_IP=$(echo "$INSTANCE_INFO" | jq -r ".[\"$FIRST_INSTANCE_ID\"].public_ip // .[\"$FIRST_INSTANCE_ID\"].private_ip")
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "null" ]; then
            echo "❌ Could not determine instance IP address"
            echo "Instance info: $INSTANCE_INFO"
            exit 1
          fi
          
          echo "Testing SSH connectivity to instance: $FIRST_INSTANCE_ID at $INSTANCE_IP"
          
          # Test SSH connectivity for each user
          for user in alice bob charlie diana eve; do
            echo "Testing SSH authentication for user: $user"
            
            # Download the private key for this user
            echo "Downloading private key for $user..."
            if aws s3 cp s3://${{ env.ssh_keys_bucket_name }}/keys/${user}_private_key /tmp/${user}_private_key; then
              echo "✅ Private key downloaded for $user"
              
              # Set proper permissions on private key
              chmod 600 /tmp/${user}_private_key
              
              # Test SSH connection (with timeout to avoid hanging)
              echo "Testing SSH connection for $user@$INSTANCE_IP..."
              if timeout 30 ssh -i /tmp/${user}_private_key \
                   -o StrictHostKeyChecking=no \
                   -o ConnectTimeout=10 \
                   -o UserKnownHostsFile=/dev/null \
                   ${user}@${INSTANCE_IP} \
                   "echo '✅ SSH authentication successful for $user on $INSTANCE_IP' && whoami && pwd" 2>&1; then
                echo "✅ SSH authentication test PASSED for $user"
              else
                echo "❌ SSH authentication test FAILED for $user"
                echo "This could indicate:"
                echo "1. SSH key not properly installed on instance"
                echo "2. User account not created correctly"
                echo "3. SSH service not running on instance"
                echo "4. Security group blocking SSH access"
                echo "5. Private key format issues"
              fi
              
              # Clean up private key
              rm -f /tmp/${user}_private_key
            else
              echo "❌ Failed to download private key for $user"
            fi
            
            echo "---"
          done
          
          echo "=== SSH Authentication Testing Complete ==="
          
      - name: Verify SSH Key Installation on Instance
        run: |
          set -e
          echo "=== Verifying SSH Key Installation on Instance ==="
          
          # Get instance information from Terraform
          cd terraform
          INSTANCE_INFO=$(terraform output -json provisioned_instances)
          FIRST_INSTANCE_ID=$(echo "$INSTANCE_INFO" | jq -r 'keys[0]')
          INSTANCE_IP=$(echo "$INSTANCE_INFO" | jq -r ".[\"$FIRST_INSTANCE_ID\"].public_ip // .[\"$FIRST_INSTANCE_ID\"].private_ip")
          
          echo "Verifying SSH key installation on instance: $FIRST_INSTANCE_ID at $INSTANCE_IP"
          
          # Use the first user's private key to connect and verify all users
          FIRST_USER="alice"
          echo "Using $FIRST_USER's private key to verify all user setups..."
          
          # Download the first user's private key
          if aws s3 cp s3://${{ env.ssh_keys_bucket_name }}/keys/${FIRST_USER}_private_key /tmp/${FIRST_USER}_private_key; then
            chmod 600 /tmp/${FIRST_USER}_private_key
            
            # Connect to instance and verify all user setups
            echo "Connecting to instance to verify user setups..."
            ssh -i /tmp/${FIRST_USER}_private_key \
                -o StrictHostKeyChecking=no \
                -o ConnectTimeout=10 \
                -o UserKnownHostsFile=/dev/null \
                ${FIRST_USER}@${INSTANCE_IP} << 'EOF'
              
              echo "=== User Account Verification ==="
              
              # Check if all users exist
              for user in alice bob charlie diana eve; do
                echo "Checking user: $user"
                
                # Check if user exists
                if id "$user" >/dev/null 2>&1; then
                  echo "✅ User $user exists"
                  
                  # Check if .ssh directory exists
                  if [ -d "/home/$user/.ssh" ]; then
                    echo "✅ .ssh directory exists for $user"
                    
                    # Check authorized_keys file
                    if [ -f "/home/$user/.ssh/authorized_keys" ]; then
                      echo "✅ authorized_keys file exists for $user"
                      
                      # Check file permissions
                      PERMS=$(stat -c "%a" "/home/$user/.ssh/authorized_keys")
                      if [ "$PERMS" = "600" ]; then
                        echo "✅ Correct permissions (600) on authorized_keys for $user"
                      else
                        echo "❌ Incorrect permissions ($PERMS) on authorized_keys for $user"
                      fi
                      
                      # Check file ownership
                      OWNER=$(stat -c "%U" "/home/$user/.ssh/authorized_keys")
                      if [ "$OWNER" = "$user" ]; then
                        echo "✅ Correct ownership ($OWNER) on authorized_keys for $user"
                      else
                        echo "❌ Incorrect ownership ($OWNER) on authorized_keys for $user"
                      fi
                      
                      # Check key content
                      KEY_CONTENT=$(cat "/home/$user/.ssh/authorized_keys")
                      if [ -n "$KEY_CONTENT" ] && [[ "$KEY_CONTENT" == *"ssh-rsa"* ]]; then
                        echo "✅ Valid SSH key content found for $user"
                      else
                        echo "❌ Invalid or empty SSH key content for $user"
                      fi
                    else
                      echo "❌ authorized_keys file missing for $user"
                    fi
                  else
                    echo "❌ .ssh directory missing for $user"
                  fi
                else
                  echo "❌ User $user does not exist"
                fi
                
                echo "---"
              done
              
              echo "=== SSH Service Status ==="
              if systemctl is-active --quiet sshd; then
                echo "✅ SSH service (sshd) is running"
              else
                echo "❌ SSH service (sshd) is not running"
              fi
              
              echo "=== SSH Configuration ==="
              if [ -f "/etc/ssh/sshd_config" ]; then
                echo "✅ SSH config file exists"
                
                # Check if password authentication is disabled (recommended)
                if grep -q "^PasswordAuthentication no" /etc/ssh/sshd_config; then
                  echo "✅ Password authentication is disabled (secure)"
                else
                  echo "⚠️  Password authentication may be enabled"
                fi
              else
                echo "❌ SSH config file missing"
              fi
              
            EOF
            
            # Clean up private key
            rm -f /tmp/${FIRST_USER}_private_key
            echo "✅ SSH key installation verification completed"
          else
            echo "❌ Failed to download private key for verification"
            exit 1
          fi
          
          echo "=== End SSH Key Installation Verification ==="
          
      - name: Create S3 Bucket and Testing File
        run: |
          echo "=== Creating S3 Bucket and Testing File ==="
          
          # Create unique bucket name with timestamp
          BUCKET_NAME="ec2-user-provisioning-$(date +%Y%m%d-%H%M%S)"
          echo "Creating bucket: $BUCKET_NAME"
          
          # Create S3 bucket
          aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} || {
            echo "⚠️  Bucket creation failed, trying alternative name..."
            BUCKET_NAME="ec2-user-provisioning-test-$(date +%Y%m%d)"
            aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} || {
              echo "❌ Failed to create S3 bucket"
              echo "This might be due to:"
              echo "1. Insufficient S3 permissions"
              echo "2. Bucket name already exists"
              echo "3. Invalid bucket name format"
              exit 1
            }
          }
          
          echo "✅ S3 bucket created successfully: s3://$BUCKET_NAME"
          
          # Create empty testing file
          touch testing
          echo "Empty testing file created locally"
          
          # Upload testing file to S3
          aws s3 cp testing s3://$BUCKET_NAME/testing || {
            echo "❌ Failed to upload testing file to S3"
            echo "Bucket created but file upload failed"
            exit 1
          }
          
          echo "✅ Testing file uploaded successfully: s3://$BUCKET_NAME/testing"
          
          # List contents to verify
          echo "📋 Bucket contents:"
          aws s3 ls s3://$BUCKET_NAME/ || {
            echo "⚠️  Could not list bucket contents"
          }
          
          echo "=== End S3 Bucket and Testing File ==="
          
      # - name: Upload Terraform Outputs
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: terraform-outputs
      #     path: terraform/terraform_output.json
      #     retention-days: 7

  # send-email-keys:
  #   name: Send SSH Keys to Users
  #   needs: provision-users
  #   runs-on: docker
  #   if: |
  #     github.event_name == 'workflow_dispatch' &&
  #     github.event.inputs.send_emails != 'false' &&
  #     github.event.inputs.dry_run != 'true' &&
  #     github.event_inputs.dry_run != true
  #   permissions:
  #     id-token: write
  #     contents: read
  #   
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       
  #     - name: Install Python dependencies
  #       run: |
  #         python3 -m pip install --upgrade pip
  #         pip3 install pyyaml
  #         
  #     - name: Download Terraform Outputs
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-outputs
  #         path: terraform/
  #         
  #     - name: Send SSH Keys via Email
  #       timeout-minutes: 5
  #       run: |
  #         set -e
  #         # Validate required SMTP secrets
  #         if [ -z "${{ secrets.SMTP_HOST }}" ] || [ -z "${{ secrets.SMTP_USER }}" ] || [ -z "${{ secrets.SMTP_PASS }}" ]; then
  #           echo "❌ Required SMTP secrets are not set"
  #           echo "Please add SMTP_HOST, SMTP_USER, and SMTP_PASS secrets to your repository settings"
  #           exit 1
  #         fi
  #         
  #         python3 scripts/send_keys.py \
  #           --smtp-host "${{ secrets.SMTP_HOST }}" \
  #           --smtp-user "${{ secrets.SMTP_USER }}" \
  #           --smtp-pass "${{ secrets.SMTP_PASS }}" \
  #           --smtp-port "${{ secrets.SMTP_PORT || '587' }}" \
  #           --users-file users.yaml \
  #           --terraform-dir terraform || {
  #           echo "❌ Failed to send SSH keys via email"
  #           exit 1
  #         }

 