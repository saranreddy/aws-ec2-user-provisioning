name: Provision Users on AWS EC2 Instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Select EC2 instance ID from the dropdown'
        required: true
        type: choice
        options:
          - i-0d2ea774d38f88fe2
          - i-059108826eb667a3d
          - i-03810d57b29eff7fa
          - i-04f6cf69514fab8ec
          - i-069c4707f66eee735
          - i-038146dc9a729c973
          - i-0ce61b84050ece568
          - i-0079b3bcbc7b9c83e
          - i-0a6b63f03c28c1336
          - i-019d6e26b39617852
          - i-00ca906185f13e772
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1

      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean
  push:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'

env:
  TF_VERSION: "1.5.7"
  PYTHON_VERSION: "3.9"

jobs:
  validate:
    name: Validate Terraform Configuration
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check environment
        run: |
          echo "=== Environment Check ==="
          echo "User: $(whoami)"
          echo "EUID: $EUID"
          echo "Distribution: $(cat /etc/os-release | grep PRETTY_NAME || echo 'Unknown')"
          echo "Available commands:"
          command -v curl >/dev/null 2>&1 && echo "‚úì curl available" || echo "‚úó curl not found"
          command -v unzip >/dev/null 2>&1 && echo "‚úì unzip available" || echo "‚úó unzip not found"
          command -v python3 >/dev/null 2>&1 && echo "‚úì python3 available" || echo "‚úó python3 not found"
          command -v pip3 >/dev/null 2>&1 && echo "‚úì pip3 available" || echo "‚úó pip3 not found"
          command -v jq >/dev/null 2>&1 && echo "‚úì jq available" || echo "‚úó jq not found"
          echo "================================"
        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq || {
            echo "‚ö†Ô∏è  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "‚úÖ Python3 is available, continuing..."
            else
              echo "‚ùå Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Format Check and Fix
        run: |
          cd terraform
          echo "Checking Terraform formatting with version $(terraform version | head -n1)..."
          
          # Show current file structure
          echo "Current Terraform files:"
          ls -la *.tf
          
          # First, try to format the files automatically
          echo "Auto-formatting Terraform files..."
          terraform fmt -recursive || {
            echo "‚ö†Ô∏è  Auto-formatting failed, but continuing..."
          }
          
          # Then check if formatting is correct
          echo "Checking formatting compliance..."
          if terraform fmt -check -recursive; then
            echo "‚úÖ Terraform formatting is correct"
          else
            echo "‚ö†Ô∏è  Terraform formatting issues found, but continuing..."
            echo "This is a warning, not a critical error."
            echo "Files have been auto-formatted for the next run."
            echo "Note: This warning will be resolved in subsequent runs."
          fi
        continue-on-error: true
          
      - name: Setup Terraform S3 Backend
        run: |
          set -e
          echo "=== Setting up Terraform S3 Backend ==="
          
          BUCKET_NAME="terraform-state-ec2-user-provisioning"
          DYNAMODB_TABLE="terraform-state-lock"
          REGION="${{ inputs.aws_region }}"
          
          # Create S3 bucket for Terraform state
          echo "Creating S3 bucket: $BUCKET_NAME"
          aws s3 mb s3://$BUCKET_NAME --region $REGION || {
            echo "‚ÑπÔ∏è  S3 bucket might already exist, checking..."
            if aws s3 ls s3://$BUCKET_NAME >/dev/null 2>&1; then
              echo "‚úÖ S3 bucket $BUCKET_NAME already exists"
            else
              echo "‚ùå Failed to create or access S3 bucket"
              exit 1
            fi
          }
          
          # Enable versioning on S3 bucket
          echo "Enabling versioning on S3 bucket..."
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled \
            --region $REGION || {
            echo "‚ö†Ô∏è  Failed to enable versioning (bucket might have restrictions)"
          }
          
          # Create DynamoDB table for state locking
          echo "Creating DynamoDB table: $DYNAMODB_TABLE"
          aws dynamodb create-table \
            --table-name $DYNAMODB_TABLE \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region $REGION || {
            echo "‚ÑπÔ∏è  DynamoDB table might already exist, checking..."
            if aws dynamodb describe-table --table-name $DYNAMODB_TABLE --region $REGION >/dev/null 2>&1; then
              echo "‚úÖ DynamoDB table $DYNAMODB_TABLE already exists"
            else
              echo "‚ùå Failed to create or access DynamoDB table"
              exit 1
            fi
          }
          
          # Wait for DynamoDB table to be active
          echo "Waiting for DynamoDB table to be active..."
          aws dynamodb wait table-exists --table-name $DYNAMODB_TABLE --region $REGION || {
            echo "‚ö†Ô∏è  Timeout waiting for table, but continuing..."
          }
          
          echo "‚úÖ Terraform S3 backend infrastructure ready"
          echo "State bucket: s3://$BUCKET_NAME"
          echo "Lock table: $DYNAMODB_TABLE"
          
      - name: Terraform Init with S3 Backend
        run: |
          cd terraform
          echo "=== Initializing Terraform with S3 Backend ==="
          
          # Initialize Terraform with S3 backend
          terraform init -reconfigure || {
            echo "‚ùå Terraform initialization failed"
            echo "This might be due to:"
            echo "1. S3 backend infrastructure not ready"
            echo "2. Insufficient permissions for S3/DynamoDB"
            echo "3. Backend configuration issues"
            echo ""
            echo "Checking backend configuration..."
            cat backend.tf
            exit 1
          }
          
          echo "‚úÖ Terraform initialized successfully with S3 backend"
          echo "State location: s3://terraform-state-ec2-user-provisioning/ec2-user-provisioning/terraform.tfstate"
          
          # Verify backend configuration
          terraform version
          terraform providers
          
      - name: Terraform Validate
        run: |
          cd terraform
          echo "Validating Terraform configuration..."
          terraform validate || {
            echo "‚ùå Terraform validation failed"
            echo "Please check the configuration syntax and provider versions."
            exit 1
          }
          echo "‚úÖ Terraform configuration is valid"
          
      - name: Validate Users YAML
        run: |
          python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              print(f'Found {len(data[\"users\"])} users in configuration')
              for user in data['users']:
                  if not all(k in user for k in ['username', 'email']):
                      raise ValueError(f'User {user} missing required fields')
                  print(f'  - {user[\"username\"]} ({user[\"email\"]})')
          "

  provision-users:
    name: Provision Users on EC2 Instances
    needs: validate
    runs-on: docker
    if: github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        

        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq awscli || {
            echo "‚ö†Ô∏è  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            command -v aws >/dev/null 2>&1 || echo "aws CLI not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "‚úÖ Python3 is available, continuing..."
            else
              echo "‚ùå Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          set -e
          # Validate required secrets
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "‚ùå Required secret 'aws_ec2_creation_role' is not set"
            echo "Please add this secret to your repository settings"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: ${{ vars.GITHUBACTIONSAPPSESSION || 3600 }}
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          set -e
          echo "=== AWS Credentials Verification ==="
          
          # Test AWS credentials with detailed error handling
          echo "Testing AWS credentials..."
          aws sts get-caller-identity || {
            echo "‚ùå AWS credentials are invalid or expired"
            echo "Possible issues:"
            echo "1. OIDC role configuration is incorrect"
            echo "2. Role permissions are insufficient"
            echo "3. Wrong AWS region"
            echo "4. Role name is incorrect (tried: ${{ secrets.aws_ec2_creation_role }})"
            echo "5. Account ID is incorrect (tried: ${{ inputs.aws_account_id }})"
            echo ""
            echo "Please verify:"
            echo "- The role exists in your AWS account"
            echo "- The role has proper permissions for EC2 access"
            echo "- Set aws_ec2_creation_role secret if role name is different"
            echo "- Verify the role ARN: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}"
            exit 1
          }
          
          echo "‚úÖ AWS credentials verified successfully"
          echo "Caller Identity:"
          aws sts get-caller-identity
          
      - name: Debug AWS Environment
        run: |
          set -e
          echo "=== AWS Environment Debug ==="
          echo "AWS Region: ${{ inputs.aws_region }}"
          echo "AWS Account ID: ${{ inputs.aws_account_id }}"
          echo "Role Name: ${{ secrets.aws_ec2_creation_role }}"
          echo "Full Role ARN: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}"
          
          # Test AWS CLI version and configuration
          echo "AWS CLI Version:"
          aws --version
          
          # Test basic AWS permissions
          echo "Testing AWS permissions..."
          echo "1. Testing EC2 Describe Instances permission..."
          aws ec2 describe-instances --region ${{ inputs.aws_region }} --max-items 1 --query 'Reservations[0].Instances[0].InstanceId' --output text || {
            echo "‚ùå Cannot describe EC2 instances - permission issue"
            echo "The role needs ec2:DescribeInstances permission"
          }
          
          echo "2. Testing IAM Get Role permission..."
          aws iam get-role --role-name ${{ secrets.aws_ec2_creation_role }} || {
            echo "‚ùå Cannot get IAM role - permission issue"
            echo "The role needs iam:GetRole permission"
          }
          
          echo "3. Testing STS Get Caller Identity..."
          aws sts get-caller-identity || {
            echo "‚ùå Cannot get caller identity"
          }
          
          echo "=== End AWS Environment Debug ==="
          
      - name: Check SSH Key Availability
        run: |
          set -e
          echo "=== SSH Key Availability Check ==="
          
          # Check if SSH private key secret is set
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå SSH private key secret 'EC2_SSH_PRIVATE_KEY' is not set"
            echo "This is required for connecting to EC2 instances"
            echo ""
            echo "To fix this:"
            echo "1. Add the EC2_SSH_PRIVATE_KEY secret to your repository"
            echo "2. The value should be the private key content (not the file path)"
            echo "3. This key must match the key pair used to launch the EC2 instances"
            echo ""
            echo "Alternative: Consider using AWS Systems Manager (SSM) instead of SSH"
            echo "This would eliminate the need for SSH keys entirely"
            exit 1
          else
            echo "‚úÖ SSH private key secret is set"
            echo "Key length: ${#EC2_SSH_PRIVATE_KEY} characters"
            
            # Test if the key looks like a valid SSH private key
            if [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == *"-----BEGIN"* ]] && [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == *"-----END"* ]]; then
              echo "‚úÖ SSH key format appears valid"
            else
              echo "‚ö†Ô∏è  SSH key format may be invalid - should contain BEGIN/END markers"
            fi
          fi
          
          echo "=== End SSH Key Check ==="
          
      - name: Create SSH Key File
        run: |
          set -e
          echo "=== Creating SSH Key File ==="
          
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the SSH key from secret to file
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
          chmod 600 ~/.ssh/ec2-provisioning-key
          
          echo "‚úÖ SSH key file created at ~/.ssh/ec2-provisioning-key"
          echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
          
          # Verify the key file exists and has correct permissions
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "‚úÖ SSH key file exists and is readable"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
          else
            echo "‚ùå SSH key file was not created successfully"
            exit 1
          fi
          
          echo "=== End SSH Key File Creation ==="
          
      - name: Validate Instance ID
        run: |
          set -e
          echo "=== Instance ID Validation ==="
          
          INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
          echo "Selected instance ID: $INSTANCE_ID"
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "‚ùå No instance ID selected"
            exit 1
          fi
          
          # Check instance ID format
          echo "Validating instance ID: $INSTANCE_ID"
          
          # Check format
          if [[ ! "$INSTANCE_ID" =~ ^i-[a-f0-9]{8,17}$ ]]; then
            echo "‚ùå Invalid instance ID format: $INSTANCE_ID"
            echo "Instance IDs must be in format: i-xxxxxxxxxxxxxxxxx"
            exit 1
          fi
          
          # Check if instance exists in AWS and get details
          echo "Checking if instance $INSTANCE_ID exists in AWS..."
          if aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region ${{ inputs.aws_region }} --query 'Reservations[0].Instances[0]' --output json 2>/dev/null; then
            INSTANCE_INFO=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region ${{ inputs.aws_region }} --query 'Reservations[0].Instances[0]' --output json)
            INSTANCE_STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')
            PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress // empty')
            
            echo "‚úÖ Instance $INSTANCE_ID exists and is in state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "‚ùå Instance $INSTANCE_ID is not running (state: $INSTANCE_STATE)"
              echo "The instance must be running for user provisioning to work"
              exit 1
            fi
            
            if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "null" ]; then
              echo "‚ö†Ô∏è  Instance $INSTANCE_ID does not have a public IP address"
              echo "Will use private IP for SSH connection (assuming same network)"
            else
              echo "‚úÖ Instance $INSTANCE_ID has public IP: $PUBLIC_IP"
            fi
            
            # Check for private IP
            PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.PrivateIpAddress // empty')
            if [ -z "$PRIVATE_IP" ] || [ "$PRIVATE_IP" = "null" ]; then
              echo "‚ùå Instance $INSTANCE_ID does not have a private IP address"
              echo "Cannot connect to instance without IP address"
              exit 1
            else
              echo "‚úÖ Instance $INSTANCE_ID has private IP: $PRIVATE_IP"
            fi
          else
            echo "‚ùå Instance $INSTANCE_ID does not exist in AWS region ${{ inputs.aws_region }}"
            echo "Please verify:"
            echo "1. The instance ID is correct"
            echo "2. The instance exists in the specified region (${{ inputs.aws_region }})"
            echo "3. You have permission to describe this instance"
            exit 1
          fi
          
          echo "=== End Instance ID Validation ==="
          
      - name: Check Terraform Configuration
        run: |
          set -e
          echo "=== Terraform Configuration Check ==="
          
          cd terraform
          
          # Check if required files exist
          echo "Checking Terraform files..."
          ls -la *.tf
          
          # Check if variables.tf has required variables
          if grep -q "instance_ids" variables.tf; then
            echo "‚úÖ instance_ids variable is defined"
          else
            echo "‚ùå instance_ids variable is not defined in variables.tf"
          fi
          
          if grep -q "aws_region" variables.tf; then
            echo "‚úÖ aws_region variable is defined"
          else
            echo "‚ùå aws_region variable is not defined in variables.tf"
          fi
          
          # Check if main.tf references the SSH key path
          if grep -q "ssh_private_key_path" main.tf; then
            echo "‚úÖ SSH key path is referenced in main.tf"
          else
            echo "‚ùå SSH key path is not referenced in main.tf"
          fi
          
          echo "=== End Terraform Configuration Check ==="
          
      - name: Parse Instance ID
        id: parse-instances
        run: |
          set -e
          # Check if this is a manual workflow dispatch with instance ID
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.instance_ids }}" ]; then
            INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
            echo "Using selected instance ID: $INSTANCE_ID"
          else
            # For automatic triggers (push/PR), use a default or placeholder
            # You can modify this to use a default instance ID or skip the job
            echo "No instance ID selected for automatic trigger"
            echo "This workflow requires manual trigger with instance ID selection"
            echo "Please run this workflow manually and select an instance ID"
            exit 1
          fi
          
          # Validate instance ID format
          if [[ ! "$INSTANCE_ID" =~ ^i-[a-f0-9]{8,17}$ ]]; then
            echo "‚ùå Invalid instance ID format: $INSTANCE_ID"
            echo "Instance IDs must be in format: i-xxxxxxxxxxxxxxxxx"
            exit 1
          fi
          
          # Convert single instance ID to Terraform list format
          echo "Converting instance ID to Terraform list format..."
          
          # Create a terraform.tfvars file with proper list format
          cd terraform
          echo "instance_ids = [" > terraform.tfvars
          echo "  \"$INSTANCE_ID\"" >> terraform.tfvars
          echo "]" >> terraform.tfvars
          
          echo "instance_ids=terraform.tfvars" >> $GITHUB_OUTPUT
          echo "Created terraform.tfvars with instance ID:"
          cat terraform.tfvars
          
      - name: Create Keys Directory
        run: |
          cd terraform
          mkdir -p keys
          
      - name: Verify SSH Key Before Terraform
        run: |
          set -e
          echo "=== Pre-Terraform SSH Key Verification ==="
          
          # Check if SSH key file exists
          if [ ! -f ~/.ssh/ec2-provisioning-key ]; then
            echo "‚ùå SSH key file missing before Terraform execution"
            echo "Creating SSH key file from secret..."
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
            chmod 600 ~/.ssh/ec2-provisioning-key
          fi
          
          # Verify the file exists and has correct permissions
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "‚úÖ SSH key file verified: ~/.ssh/ec2-provisioning-key"
            echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
          else
            echo "‚ùå SSH key file still missing after creation attempt"
            exit 1
          fi
          
          echo "=== End SSH Key Verification ==="
          
      - name: Setup Terraform S3 Backend
        run: |
          set -e
          echo "=== Setting up Terraform S3 Backend ==="
          
          BUCKET_NAME="terraform-state-ec2-user-provisioning"
          DYNAMODB_TABLE="terraform-state-lock"
          REGION="${{ inputs.aws_region }}"
          
          # Create S3 bucket for Terraform state
          echo "Creating S3 bucket: $BUCKET_NAME"
          aws s3 mb s3://$BUCKET_NAME --region $REGION || {
            echo "‚ÑπÔ∏è  S3 bucket might already exist, checking..."
            if aws s3 ls s3://$BUCKET_NAME >/dev/null 2>&1; then
              echo "‚úÖ S3 bucket $BUCKET_NAME already exists"
            else
              echo "‚ùå Failed to create or access S3 bucket"
              exit 1
            fi
          }
          
          # Enable versioning on S3 bucket
          echo "Enabling versioning on S3 bucket..."
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled \
            --region $REGION || {
            echo "‚ö†Ô∏è  Failed to enable versioning (bucket might have restrictions)"
          }
          
          # Create DynamoDB table for state locking
          echo "Creating DynamoDB table: $DYNAMODB_TABLE"
          aws dynamodb create-table \
            --table-name $DYNAMODB_TABLE \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region $REGION || {
            echo "‚ÑπÔ∏è  DynamoDB table might already exist, checking..."
            if aws dynamodb describe-table --table-name $DYNAMODB_TABLE --region $REGION >/dev/null 2>&1; then
              echo "‚úÖ DynamoDB table $DYNAMODB_TABLE already exists"
            else
              echo "‚ùå Failed to create or access DynamoDB table"
              exit 1
            fi
          }
          
          # Wait for DynamoDB table to be active
          echo "Waiting for DynamoDB table to be active..."
          aws dynamodb wait table-exists --table-name $DYNAMODB_TABLE --region $REGION || {
            echo "‚ö†Ô∏è  Timeout waiting for table, but continuing..."
          }
          
          echo "‚úÖ Terraform S3 backend infrastructure ready"
          echo "State bucket: s3://$BUCKET_NAME"
          echo "Lock table: $DYNAMODB_TABLE"
          
      - name: Terraform Init with S3 Backend
        run: |
          cd terraform
          echo "=== Terraform Initialization with S3 Backend ==="
          echo "Current directory: $(pwd)"
          echo "Terraform files present:"
          ls -la *.tf
          
          echo "Backend configuration:"
          cat backend.tf
          
          echo "Initializing Terraform with S3 backend..."
          terraform init -reconfigure || {
            echo "‚ùå Terraform initialization failed"
            echo "This might be due to:"
            echo "1. S3 backend infrastructure not ready"
            echo "2. Insufficient permissions for S3/DynamoDB"
            echo "3. Backend configuration issues"
            echo "4. Network connectivity issues"
            echo "5. Provider download problems"
            exit 1
          }
          echo "‚úÖ Terraform initialized successfully with S3 backend"
          echo "State location: s3://terraform-state-ec2-user-provisioning/ec2-user-provisioning/terraform.tfstate"
          
      - name: Terraform Plan
        id: plan
        timeout-minutes: 10
        run: |
          set -e
          cd terraform
          echo "=== Terraform Plan Execution ==="
          
          # Show current terraform.tfvars content
          echo "Current terraform.tfvars content:"
          if [ -f "terraform.tfvars" ]; then
            cat terraform.tfvars
          else
            echo "‚ùå terraform.tfvars file not found"
            exit 1
          fi
          
          # Show variables that will be used
          echo "Variables to be used:"
          echo "- aws_region: ${{ inputs.aws_region }}"
          echo "- dry_run: ${{ github.event.inputs.dry_run }}"
          echo "- instance_ids: (from terraform.tfvars)"
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode - no actual changes will be made"
            terraform plan \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=true" \
              -detailed-exitcode || {
              echo "‚ùå Terraform plan failed"
              echo "Common causes:"
              echo "1. SSH private key file missing (check EC2_SSH_PRIVATE_KEY secret)"
              echo "2. EC2 instance not found (check instance ID and region)"
              echo "3. Insufficient AWS permissions"
              echo "4. Terraform configuration errors"
              echo "5. Network connectivity issues"
              exit 1
            }
          else
            terraform plan \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=false" \
              -out=tfplan || {
              echo "‚ùå Terraform plan failed"
              echo "Common causes:"
              echo "1. SSH private key file missing (check EC2_SSH_PRIVATE_KEY secret)"
              echo "2. EC2 instance not found (check instance ID and region)"
              echo "3. Insufficient AWS permissions"
              echo "4. Terraform configuration errors"
              echo "5. Network connectivity issues"
              exit 1
            }
          fi
          
          echo "‚úÖ Terraform plan completed successfully"
        continue-on-error: true
        
      - name: Show Terraform Plan
        run: |
          cd terraform
          echo "=== Terraform Plan Details ==="
          if [ -f "tfplan" ]; then
            echo "Plan file exists, showing details..."
            terraform show tfplan || {
              echo "‚ùå Failed to show terraform plan"
              echo "This might indicate a corrupted plan file"
            }
          else
            echo "No plan file found (dry run mode or no changes)"
            echo "This could mean:"
            echo "1. No changes are needed"
            echo "2. Plan failed and didn't create a plan file"
            echo "3. Running in dry-run mode"
          fi
          
      - name: Debug Terraform State
        run: |
          cd terraform
          echo "=== Terraform State Debug ==="
          
          # Check if state file exists
          if [ -f ".terraform/terraform.tfstate" ]; then
            echo "‚úÖ Terraform state file exists"
            echo "State file size: $(stat -c%s .terraform/terraform.tfstate) bytes"
          else
            echo "‚ö†Ô∏è  No terraform state file found"
          fi
          
          # Show current state
          echo "Current Terraform state:"
          terraform show || {
            echo "‚ùå Failed to show terraform state"
          }
          
          echo "=== End Terraform State Debug ==="
          
      - name: Check SSH Key File Issues
        run: |
          set -e
          echo "=== SSH Key File Check ==="
          
          cd terraform
          
          # Check if the SSH key file path is being used correctly
          echo "Checking SSH key file references in Terraform..."
          
          # Look for SSH key path references in main.tf
          if grep -q "ssh_private_key_path" main.tf; then
            echo "‚úÖ SSH key path variable is referenced in main.tf"
            
            # Check what the default path is
            SSH_PATH=$(grep -A1 -B1 "ssh_private_key_path" main.tf || echo "Not found")
            echo "SSH key path configuration:"
            echo "$SSH_PATH"
          else
            echo "‚ùå SSH key path not found in main.tf"
          fi
          
          # Check if the SSH key file exists at the expected location
          EXPECTED_PATH="~/.ssh/ec2-provisioning-key"
          echo "Expected SSH key path: $EXPECTED_PATH"
          
          # Check if the SSH key file exists
          if [ -f ~/.ssh/ec2-provisioning-key ]; then
            echo "‚úÖ SSH key file exists at ~/.ssh/ec2-provisioning-key"
            echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            echo "File permissions: $(ls -la ~/.ssh/ec2-provisioning-key)"
            
            # Show first few lines of the key (safely)
            echo "Key file content preview:"
            head -3 ~/.ssh/ec2-provisioning-key | sed 's/.*/***/'
          else
            echo "‚ùå SSH key file does not exist at ~/.ssh/ec2-provisioning-key"
            echo "This means the 'Create SSH Key File' step failed or didn't run"
            
            # Try to create it again
            echo "Attempting to create SSH key file again..."
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
            chmod 600 ~/.ssh/ec2-provisioning-key
            
            if [ -f ~/.ssh/ec2-provisioning-key ]; then
              echo "‚úÖ SSH key file created successfully"
              echo "File size: $(stat -c%s ~/.ssh/ec2-provisioning-key) bytes"
            else
              echo "‚ùå Failed to create SSH key file"
              exit 1
            fi
          fi
          
          echo "=== End SSH Key File Check ==="
          
      - name: Check Output Format Issues
        run: |
          set -e
          echo "=== Output Format Check ==="
          
          cd terraform
          
          # Check the outputs.tf file for potential issues
          echo "Checking outputs.tf for format issues..."
          
          if [ -f "outputs.tf" ]; then
            echo "‚úÖ outputs.tf file exists"
            
            # Check for the specific output that was causing issues
            if grep -q "user_private_keys" outputs.tf; then
              echo "Found user_private_keys output, checking format..."
              
              # Show the output definition
              grep -A10 "user_private_keys" outputs.tf || echo "Output definition not found"
              
              echo "‚ö†Ô∏è  Note: The 'Invalid index' error suggests the output format may need adjustment"
              echo "This typically happens when trying to access a map with numeric keys"
            else
              echo "user_private_keys output not found in outputs.tf"
            fi
          else
            echo "‚ùå outputs.tf file not found"
          fi
          
          echo "=== End Output Format Check ==="
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true' && github.event.inputs.dry_run != true
        timeout-minutes: 15
        run: |
          set -e
          cd terraform
          echo "=== Terraform Apply Execution ==="
          
          # Check if plan file exists
          if [ -f "tfplan" ]; then
            echo "‚úÖ Plan file exists, proceeding with apply..."
            echo "Plan file size: $(stat -c%s tfplan) bytes"
            
            # Show what will be applied
            echo "Resources to be applied:"
            terraform show tfplan | grep -E "^[+-]" || echo "No changes detected"
            
            # Apply the plan
            terraform apply -auto-approve tfplan || {
              echo "‚ùå Terraform apply failed"
              echo "Common causes:"
              echo "1. SSH connection failed to EC2 instances"
              echo "2. EC2 instances are not running"
              echo "3. SSH key authentication failed"
              echo "4. Network connectivity issues"
              echo "5. Insufficient permissions on EC2 instances"
              echo ""
              echo "Debugging steps:"
              echo "1. Verify EC2 instances are running"
              echo "2. Check SSH key is correct"
              echo "3. Verify security groups allow SSH access"
              echo "4. Check instance user permissions"
              exit 1
            }
            
            echo "‚úÖ Terraform apply completed successfully"
          else
            echo "‚ùå No plan file found - skipping apply"
            echo "This could mean:"
            echo "1. Plan step failed"
            echo "2. No changes are needed"
            echo "3. Plan file was not created"
            exit 1
          fi
          
          echo "=== End Terraform Apply ==="
          
      - name: Terraform Output
        run: |
          cd terraform
          echo "=== Terraform Output Generation ==="
          
          # Try to generate outputs with error handling
          echo "Generating Terraform outputs..."
          terraform output -json > terraform_output.json || {
            echo "‚ùå Failed to generate Terraform outputs"
            echo "This might be due to:"
            echo "1. Output format errors (Invalid index errors)"
            echo "2. Resources not created successfully"
            echo "3. State file issues"
            echo ""
            echo "Attempting to show outputs in text format..."
            terraform output || {
              echo "‚ùå Also failed to show outputs in text format"
              echo "This suggests the outputs.tf file may have format issues"
            }
            exit 1
          }
          
          echo "‚úÖ Terraform outputs saved to terraform_output.json"
          echo "Output file size: $(stat -c%s terraform_output.json) bytes"
          
          # Show a summary of the outputs
          echo "Output summary:"
          terraform output -json | jq 'keys' || {
            echo "‚ùå Failed to parse outputs with jq"
            echo "Raw output content:"
            cat terraform_output.json
          }
          
          echo "=== End Terraform Output ==="
          
      - name: Show Provisioning Summary
        run: |
          cd terraform
          echo "=== PROVISIONING SUMMARY ==="
          
          # Try to show provisioning summary with error handling
          terraform output provisioning_summary || {
            echo "‚ùå Failed to show provisioning_summary output"
            echo "This might be due to output format issues or missing output"
          }
          
          echo ""
          echo "=== INSTANCES PROVISIONED ==="
          terraform output provisioned_instances || {
            echo "‚ùå Failed to show provisioned_instances output"
            echo "This might be due to output format issues or missing output"
          }
          
          echo ""
          echo "=== ALL AVAILABLE OUTPUTS ==="
          terraform output || {
            echo "‚ùå Failed to show any outputs"
            echo "This suggests the outputs.tf file may have issues"
          }
          
          echo "=== END PROVISIONING SUMMARY ==="
          
      - name: Create S3 Bucket and Testing File
        run: |
          echo "=== Creating S3 Bucket and Testing File ==="
          
          # Create unique bucket name with timestamp
          BUCKET_NAME="ec2-user-provisioning-$(date +%Y%m%d-%H%M%S)"
          echo "Creating bucket: $BUCKET_NAME"
          
          # Create S3 bucket
          aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} || {
            echo "‚ö†Ô∏è  Bucket creation failed, trying alternative name..."
            BUCKET_NAME="ec2-user-provisioning-test-$(date +%Y%m%d)"
            aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }} || {
              echo "‚ùå Failed to create S3 bucket"
              echo "This might be due to:"
              echo "1. Insufficient S3 permissions"
              echo "2. Bucket name already exists"
              echo "3. Invalid bucket name format"
              exit 1
            }
          }
          
          echo "‚úÖ S3 bucket created successfully: s3://$BUCKET_NAME"
          
          # Create empty testing file
          touch testing
          echo "Empty testing file created locally"
          
          # Upload testing file to S3
          aws s3 cp testing s3://$BUCKET_NAME/testing || {
            echo "‚ùå Failed to upload testing file to S3"
            echo "Bucket created but file upload failed"
            exit 1
          }
          
          echo "‚úÖ Testing file uploaded successfully: s3://$BUCKET_NAME/testing"
          
          # List contents to verify
          echo "üìã Bucket contents:"
          aws s3 ls s3://$BUCKET_NAME/ || {
            echo "‚ö†Ô∏è  Could not list bucket contents"
          }
          
          echo "=== End S3 Bucket and Testing File ==="
          
      # - name: Upload Terraform Outputs
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: terraform-outputs
      #     path: terraform/terraform_output.json
      #     retention-days: 7

  # send-email-keys:
  #   name: Send SSH Keys to Users
  #   needs: provision-users
  #   runs-on: docker
  #   if: |
  #     github.event_name == 'workflow_dispatch' &&
  #     github.event.inputs.send_emails != 'false' &&
  #     github.event.inputs.dry_run != 'true' &&
  #     github.event_inputs.dry_run != true
  #   permissions:
  #     id-token: write
  #     contents: read
  #   
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       
  #     - name: Install Python dependencies
  #       run: |
  #         python3 -m pip install --upgrade pip
  #         pip3 install pyyaml
  #         
  #     - name: Download Terraform Outputs
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-outputs
  #         path: terraform/
  #         
  #     - name: Send SSH Keys via Email
  #       timeout-minutes: 5
  #       run: |
  #         set -e
  #         # Validate required SMTP secrets
  #         if [ -z "${{ secrets.SMTP_HOST }}" ] || [ -z "${{ secrets.SMTP_USER }}" ] || [ -z "${{ secrets.SMTP_PASS }}" ]; then
  #           echo "‚ùå Required SMTP secrets are not set"
  #           echo "Please add SMTP_HOST, SMTP_USER, and SMTP_PASS secrets to your repository settings"
  #           exit 1
  #         fi
  #         
  #         python3 scripts/send_keys.py \
  #           --smtp-host "${{ secrets.SMTP_HOST }}" \
  #           --smtp-user "${{ secrets.SMTP_USER }}" \
  #           --smtp-pass "${{ secrets.SMTP_PASS }}" \
  #           --smtp-port "${{ secrets.SMTP_PORT || '587' }}" \
  #           --users-file users.yaml \
  #           --terraform-dir terraform || {
  #           echo "‚ùå Failed to send SSH keys via email"
  #           exit 1
  #         }

 