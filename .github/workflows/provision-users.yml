name: Provision Users on AWS EC2 Instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Comma-separated list of EC2 instance IDs'
        required: true
        type: string
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1

      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean
  push:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'users.yaml'
      - 'terraform/**'
      - '.github/workflows/**'

env:
  TF_VERSION: "1.5.0"
  PYTHON_VERSION: "3.9"

jobs:
  validate:
    name: Validate Terraform Configuration
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check environment
        run: |
          echo "=== Environment Check ==="
          echo "User: $(whoami)"
          echo "EUID: $EUID"
          echo "Distribution: $(cat /etc/os-release | grep PRETTY_NAME || echo 'Unknown')"
          echo "Available commands:"
          command -v curl >/dev/null 2>&1 && echo "✓ curl available" || echo "✗ curl not found"
          command -v unzip >/dev/null 2>&1 && echo "✓ unzip available" || echo "✗ unzip not found"
          command -v python3 >/dev/null 2>&1 && echo "✓ python3 available" || echo "✗ python3 not found"
          command -v pip3 >/dev/null 2>&1 && echo "✓ pip3 available" || echo "✗ pip3 not found"
          command -v jq >/dev/null 2>&1 && echo "✓ jq available" || echo "✗ jq not found"
          echo "================================"
        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq || {
            echo "⚠️  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "✅ Python3 is available, continuing..."
            else
              echo "❌ Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -recursive
          
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
          
      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate
          
      - name: Validate Users YAML
        run: |
          python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              print(f'Found {len(data[\"users\"])} users in configuration')
              for user in data['users']:
                  if not all(k in user for k in ['username', 'email']):
                      raise ValueError(f'User {user} missing required fields')
                  print(f'  - {user[\"username\"]} ({user[\"email\"]})')
          "

  provision-users:
    name: Provision Users on EC2 Instances
    needs: validate
    runs-on: docker
    if: github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        

        
      - name: Install dependencies
        run: |
          # Check if we're running as root or need sudo
          if [ "$EUID" -eq 0 ]; then
            SUDO=""
          else
            SUDO="sudo"
          fi
          
          # Update package lists with error handling
          $SUDO apt-get update || true
          
          # Install packages with better error handling
          $SUDO apt-get install -y curl unzip python3 python3-pip jq awscli || {
            echo "⚠️  Some packages failed to install, checking what's available..."
            # Check what's already available
            command -v curl >/dev/null 2>&1 || echo "curl not available"
            command -v unzip >/dev/null 2>&1 || echo "unzip not available"
            command -v python3 >/dev/null 2>&1 || echo "python3 not available"
            command -v pip3 >/dev/null 2>&1 || echo "pip3 not available"
            command -v jq >/dev/null 2>&1 || echo "jq not available"
            command -v aws >/dev/null 2>&1 || echo "aws CLI not available"
            
            # Continue if at least python3 is available
            if command -v python3 >/dev/null 2>&1; then
              echo "✅ Python3 is available, continuing..."
            else
              echo "❌ Critical dependency python3 is not available"
              exit 1
            fi
          }
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          set -e
          # Validate required secrets
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "❌ Required secret 'aws_ec2_creation_role' is not set"
            echo "Please add this secret to your repository settings"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: ${{ vars.GITHUBACTIONSAPPSESSION || 3600 }}
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          set -e
          echo "=== AWS Credentials Verification ==="
          
          # Test AWS credentials with detailed error handling
          echo "Testing AWS credentials..."
          aws sts get-caller-identity || {
            echo "❌ AWS credentials are invalid or expired"
            echo "Possible issues:"
            echo "1. OIDC role configuration is incorrect"
            echo "2. Role permissions are insufficient"
            echo "3. Wrong AWS region"
            echo "4. Role name is incorrect (tried: ${{ secrets.aws_ec2_creation_role }})"
            echo "5. Account ID is incorrect (tried: ${{ inputs.aws_account_id }})"
            echo ""
            echo "Please verify:"
            echo "- The role exists in your AWS account"
            echo "- The role has proper permissions for EC2 access"
            echo "- Set aws_ec2_creation_role secret if role name is different"
            echo "- Verify the role ARN: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}"
            exit 1
          }
          
          echo "✅ AWS credentials verified successfully"
          echo "Caller Identity:"
          aws sts get-caller-identity
          
      - name: Parse Instance IDs
        id: parse-instances
        run: |
          set -e
          # Check if this is a manual workflow dispatch with instance IDs
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.instance_ids }}" ]; then
            INSTANCE_IDS="${{ github.event.inputs.instance_ids }}"
            echo "Using manually provided instance IDs: $INSTANCE_IDS"
          else
            # For automatic triggers (push/PR), use a default or placeholder
            # You can modify this to use a default instance ID or skip the job
            echo "No instance IDs provided for automatic trigger"
            echo "This workflow requires manual trigger with instance IDs"
            echo "Please run this workflow manually and provide instance IDs"
            exit 1
          fi
          
          # Validate instance ID format
          for id in $(echo "$INSTANCE_IDS" | tr ',' ' '); do
            if [[ ! "$id" =~ ^i-[a-f0-9]{8,17}$ ]]; then
              echo "❌ Invalid instance ID format: $id"
              echo "Instance IDs must be in format: i-xxxxxxxxxxxxxxxxx"
              exit 1
            fi
          done
          
          # Convert comma-separated string to JSON array
          INSTANCE_IDS_JSON=$(echo "$INSTANCE_IDS" | tr ',' '\n' | jq -R . | jq -s .)
          echo "instance_ids=$INSTANCE_IDS_JSON" >> $GITHUB_OUTPUT
          echo "Parsed instance IDs: $INSTANCE_IDS_JSON"
          
      - name: Create Keys Directory
        run: |
          cd terraform
          mkdir -p keys
          
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
          
      - name: Terraform Plan
        id: plan
        timeout-minutes: 10
        run: |
          set -e
          cd terraform
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode - no actual changes will be made"
            terraform plan \
              -var="instance_ids=${{ steps.parse-instances.outputs.instance_ids }}" \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=true" \
              -detailed-exitcode || {
              echo "❌ Terraform plan failed"
              exit 1
            }
          else
            terraform plan \
              -var="instance_ids=${{ steps.parse-instances.outputs.instance_ids }}" \
              -var="aws_region=${{ inputs.aws_region }}" \
              -var="dry_run=false" \
              -out=tfplan || {
              echo "❌ Terraform plan failed"
              exit 1
            }
          fi
        continue-on-error: true
        
      - name: Show Terraform Plan
        run: |
          cd terraform
          if [ -f "tfplan" ]; then
            terraform show tfplan
          else
            echo "No plan file found (dry run mode or no changes)"
          fi
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true' && github.event.inputs.dry_run != true
        timeout-minutes: 15
        run: |
          set -e
          cd terraform
          if [ -f "tfplan" ]; then
            terraform apply -auto-approve tfplan || {
              echo "❌ Terraform apply failed"
              exit 1
            }
          else
            echo "No plan file found - skipping apply"
          fi
          
      - name: Terraform Output
        run: |
          cd terraform
          terraform output -json > terraform_output.json
          echo "Terraform outputs saved to terraform_output.json"
          
      - name: Show Provisioning Summary
        run: |
          cd terraform
          echo "=== PROVISIONING SUMMARY ==="
          terraform output provisioning_summary
          echo ""
          echo "=== INSTANCES PROVISIONED ==="
          terraform output provisioned_instances
          
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: terraform/terraform_output.json
          retention-days: 7

  send-email-keys:
    name: Send SSH Keys to Users
    needs: provision-users
    runs-on: docker
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.send_emails != 'false' &&
      github.event.inputs.dry_run != 'true' &&
      github.event.inputs.dry_run != true
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip3 install pyyaml
          
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: terraform/
          
      - name: Send SSH Keys via Email
        timeout-minutes: 5
        run: |
          set -e
          # Validate required SMTP secrets
          if [ -z "${{ secrets.SMTP_HOST }}" ] || [ -z "${{ secrets.SMTP_USER }}" ] || [ -z "${{ secrets.SMTP_PASS }}" ]; then
            echo "❌ Required SMTP secrets are not set"
            echo "Please add SMTP_HOST, SMTP_USER, and SMTP_PASS secrets to your repository settings"
            exit 1
          fi
          
          python3 scripts/send_keys.py \
            --smtp-host "${{ secrets.SMTP_HOST }}" \
            --smtp-user "${{ secrets.SMTP_USER }}" \
            --smtp-pass "${{ secrets.SMTP_PASS }}" \
            --smtp-port "${{ secrets.SMTP_PORT || '587' }}" \
            --users-file users.yaml \
            --terraform-dir terraform || {
            echo "❌ Failed to send SSH keys via email"
            exit 1
          }

 