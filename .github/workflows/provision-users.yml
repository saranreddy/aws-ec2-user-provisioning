name: Provision Users on AWS EC2 Instances

# Key Persistence Feature:
# - Uses fixed S3 bucket: ec2-user-provisioning-keys
# - Existing user keys are preserved across workflow runs
# - Only new users get new keys generated
# - Existing users maintain access to EC2 instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Select EC2 instance ID from the dropdown'
        required: true
        type: choice
        options:
          - i-0d2ea774d38f88fe2
          - i-059108826eb667a3d
          - i-03810d57b29eff7fa
          - i-04f6cf69514fab8ec
          - i-069c4707f66eee735
          - i-038146dc9a729c973
          - i-0ce61b84050ece568
          - i-0079b3bcbc7b9c83e
          - i-0a6b63f03c28c1336
          - i-019d6e26b39617852
          - i-00ca906185f13e772
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1
      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean

env:
  TF_VERSION: "1.5.7"

jobs:
  provision-users:
    name: Provision Users on EC2 Instances
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "❌ Required secret 'aws_ec2_creation_role' is not set"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          echo "=== AWS Credentials Verification ==="
          aws sts get-caller-identity
          echo "✅ AWS credentials verified"
          
      - name: Setup SSH Key for EC2 Access
        run: |
          echo "=== Setting up SSH Key for EC2 Access ==="
          
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "❌ Required secret 'EC2_SSH_PRIVATE_KEY' is not set"
            exit 1
          fi
          
          # Create .ssh directory and key file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
          chmod 600 ~/.ssh/ec2-provisioning-key
          
          echo "✅ SSH key file created at ~/.ssh/ec2-provisioning-key"
          
      - name: Get EC2 Instance Details
        run: |
          echo "=== Getting EC2 Instance Details ==="
          
          INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
          REGION="${{ inputs.aws_region }}"
          
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --region $REGION \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          # Try to get public IP first, fall back to private IP if public is not available
          PUBLIC_IP=$(echo $INSTANCE_INFO | jq -r '.PublicIpAddress')
          PRIVATE_IP=$(echo $INSTANCE_INFO | jq -r '.PrivateIpAddress')
          
          if [ "$PUBLIC_IP" != "null" ] && [ -n "$PUBLIC_IP" ]; then
            echo "✅ Using public IP for instance $INSTANCE_ID"
            INSTANCE_IP="$PUBLIC_IP"
            IP_TYPE="public"
          elif [ "$PRIVATE_IP" != "null" ] && [ -n "$PRIVATE_IP" ]; then
            echo "✅ Using private IP for instance $INSTANCE_ID (public IP not available)"
            INSTANCE_IP="$PRIVATE_IP"
            IP_TYPE="private"
          else
            echo "❌ Could not get IP address for instance $INSTANCE_ID"
            echo "Instance info: $INSTANCE_INFO"
              exit 1
            fi
          
          echo "Instance ID: $INSTANCE_ID"
          echo "IP Address: $INSTANCE_IP ($IP_TYPE)"
          echo "Region: $REGION"
          
          # Store for later use
          echo "EC2_INSTANCE_IP=$INSTANCE_IP" >> $GITHUB_ENV
          echo "EC2_INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "EC2_IP_TYPE=$IP_TYPE" >> $GITHUB_ENV
          
          echo "✅ EC2 instance details retrieved"
          
      - name: Generate SSH Keys (Multiple Formats)
        run: |
          echo "=== Generating SSH Keys in Multiple Formats ==="
          
          # Create temporary directory for keys
          mkdir -p /tmp/ssh_keys
          chmod 755 /tmp/ssh_keys
          
          # Install puttygen for PuTTY key conversion
          echo "Installing puttygen for key conversion..."
          if command -v apt-get &> /dev/null; then
            apt-get update && apt-get install -y putty-tools
          elif command -v yum &> /dev/null; then
            yum install -y putty
          elif command -v brew &> /dev/null; then
            brew install putty
          else
            echo "⚠️  puttygen not available, will generate basic formats only"
          fi
          
          # Read usernames from users.yaml dynamically
          echo "Reading users from users.yaml..."
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "Users found: $USERS"
          
          # Generate SSH keys for all users in multiple formats
          for user in $USERS; do
            echo "Generating keys for user: $user"
            
            # Generate RSA key pair
            if ssh-keygen -t rsa -b 4096 \
              -f /tmp/ssh_keys/${user}_key \
              -N "" \
              -C "${user}@ec2-provisioning-$(date +%Y%m%d-%H%M%S)"; then
              
              # Rename files for clarity
              mv /tmp/ssh_keys/${user}_key /tmp/ssh_keys/${user}_private_key
              mv /tmp/ssh_keys/${user}_key.pub /tmp/ssh_keys/${user}_public_key
              
              # Convert to PEM format (universal)
              cp /tmp/ssh_keys/${user}_private_key /tmp/ssh_keys/${user}_universal.pem
              chmod 600 /tmp/ssh_keys/${user}_universal.pem
              
              # Convert to PuTTY format (.ppk) if puttygen is available
              if command -v puttygen &> /dev/null; then
                echo "Converting to PuTTY format for $user..."
                if puttygen /tmp/ssh_keys/${user}_private_key -o /tmp/ssh_keys/${user}_putty.ppk -O private; then
                  echo "✅ PuTTY key generated for $user"
                else
                  echo "⚠️  Failed to generate PuTTY key for $user"
                fi
              else
                echo "⚠️  puttygen not available, skipping PuTTY format for $user"
              fi
              
              echo "✅ Generated keys for $user in multiple formats"
            else
              echo "❌ Failed to generate keys for $user"
              exit 1
            fi
          done
          
          echo "✅ All SSH keys generated successfully in multiple formats"
          
      - name: Upload SSH Keys to S3
        run: |
          echo "=== Uploading SSH Keys to S3 ==="
          
          # Use fixed S3 bucket for key persistence
          BUCKET_NAME="ec2-user-provisioning-keys"
          
          # Check if bucket exists, create if it doesn't
          if ! aws s3 ls s3://$BUCKET_NAME 2>&1 > /dev/null; then
            echo "🪣 Creating new S3 bucket: $BUCKET_NAME"
            aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }}
          else
            echo "✅ S3 bucket already exists: $BUCKET_NAME"
          fi
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "📋 Processing users: $USERS"
          echo ""
          
          # Process each user - check existing keys first
          for user in $USERS; do
            echo "🧪 Processing user: $user"
            
            # Check if user's private key already exists in S3
            if aws s3 ls s3://$BUCKET_NAME/keys/${user}_private_key 2>&1 > /dev/null; then
              echo "✅ Key already exists for $user in S3, downloading existing key"
              
              # Download existing key from S3 to local temp directory
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_private_key /tmp/ssh_keys/${user}_private_key
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_public_key /tmp/ssh_keys/${user}_public_key
              
              # Download other formats if they exist
              if aws s3 ls s3://$BUCKET_NAME/keys/${user}_universal.pem 2>&1 > /dev/null; then
                aws s3 cp s3://$BUCKET_NAME/keys/${user}_universal.pem /tmp/ssh_keys/${user}_universal.pem
              fi
              if aws s3 ls s3://$BUCKET_NAME/keys/${user}_putty.ppk 2>&1 > /dev/null; then
                aws s3 cp s3://$BUCKET_NAME/keys/${user}_putty.ppk /tmp/ssh_keys/${user}_putty.ppk
              fi
              
              echo "📥 Downloaded existing keys for $user from S3"
              
              # Mark this user as existing (no email needed)
              echo "$user:existing" >> /tmp/user_key_status.txt
            else
              echo "🆕 No existing key found for $user, uploading newly generated keys"
              
              # Upload all key formats to S3
              aws s3 cp /tmp/ssh_keys/${user}_private_key s3://$BUCKET_NAME/keys/${user}_private_key --sse AES256
              aws s3 cp /tmp/ssh_keys/${user}_public_key s3://$BUCKET_NAME/keys/${user}_public_key --sse AES256
              aws s3 cp /tmp/ssh_keys/${user}_universal.pem s3://$BUCKET_NAME/keys/${user}_universal.pem --sse AES256
              
              # Upload PuTTY format if it exists
              if [ -f "/tmp/ssh_keys/${user}_putty.ppk" ]; then
                aws s3 cp /tmp/ssh_keys/${user}_putty.ppk s3://$BUCKET_NAME/keys/${user}_putty.ppk --sse AES256
              fi
              
              echo "📤 Uploaded all key formats for $user to S3"
              
              # Mark this user as new (email needed)
              echo "$user:new" >> /tmp/user_key_status.txt
            fi
            
            echo ""
          done
          
          echo "✅ All keys processed in S3 bucket: $BUCKET_NAME"
          echo "📊 Summary: Existing keys preserved, new keys uploaded"
          
          # Show user status summary
          echo ""
          echo "📋 User Key Status Summary:"
          if [ -f /tmp/user_key_status.txt ]; then
            echo "New users (will receive emails):"
            grep ":new$" /tmp/user_key_status.txt | cut -d: -f1 | while read user; do
              echo "  ✅ $user - New key generated and uploaded"
            done
            
            echo ""
            echo "Existing users (no emails sent):"
            grep ":existing$" /tmp/user_key_status.txt | cut -d: -f1 | while read user; do
              echo "  ℹ️  $user - Existing key preserved, no email needed"
            done
          fi
          
      - name: Install SSH Keys on EC2 Instance
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Installing SSH Keys on EC2 Instance ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          SSH_USER="ec2-user"
          
          echo "Connecting to EC2 instance at $EC2_IP (${{ env.EC2_IP_TYPE }} IP)..."
          
          # Test SSH connection first
          if ssh -i ~/.ssh/ec2-provisioning-key -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SSH_USER@$EC2_IP "echo 'SSH connection successful'"; then
            echo "✅ SSH connection established"
          else
            echo "❌ Failed to establish SSH connection"
              exit 1
            fi
          
          # Make the script executable
          chmod +x scripts/install_users.sh
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          # Install each user's public key using the script
          for user in $USERS; do
            if [ -f "/tmp/ssh_keys/${user}_public_key" ]; then
              echo "Installing key for user: $user"
              
              # Read the public key content
              PUBLIC_KEY=$(cat "/tmp/ssh_keys/${user}_public_key")
              
              # Call the user provisioning script
              echo "Running user provisioning script for $user..."
              if ./scripts/install_users.sh "$user" "$PUBLIC_KEY" "$SSH_USER" "$EC2_IP"; then
                echo "✅ User $user provisioned successfully"
              else
                echo "❌ Failed to provision user $user"
              exit 1
              fi
            else
              echo "❌ SSH key for $user not found"
              exit 1
            fi
          done
          
          echo "✅ All SSH keys installed on EC2 instance"
          
      - name: Verify User Access
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Verifying User Access ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          
          echo "🔍 Verification Details:"
          echo "- EC2 Instance IP: $EC2_IP"
          echo "- Verification Timestamp: $TIMESTAMP"
          echo "- Total Users to Verify: $(echo $USERS | wc -w)"
          echo ""
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "📋 Users to verify: $USERS"
            echo ""
          
          # Test each user's SSH access with comprehensive verification
          for user in $USERS; do
            echo "🧪 Testing SSH access for user: $user"
            echo "   └─ Creating temporary key file..."
            
            # Create a temporary private key file for testing
            TEMP_KEY="/tmp/test_${user}_key"
            cp "/tmp/ssh_keys/${user}_private_key" "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"
            
            echo "   └─ Testing basic SSH connection..."
            # Test basic SSH connection
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o ConnectTimeout=10 $user@$EC2_IP "echo '✅ Basic SSH connection successful for $user'"; then
              echo "   ✅ Basic SSH connection: SUCCESS"
            else
              echo "   ❌ Basic SSH connection: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   └─ Testing user identity and home directory..."
            # Test user identity and home directory access
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "whoami && pwd && echo 'Home directory contents:' && ls -la"; then
              echo "   ✅ User identity and home directory: SUCCESS"
            else
              echo "   ❌ User identity and home directory: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   └─ Creating verification file in user's home directory..."
            # Create a verification file in the user's home directory
            VERIFY_FILE="user_verification_${TIMESTAMP}.txt"
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'User $user successfully logged in at $(date)' > ~/$VERIFY_FILE && echo 'Verification file created successfully' && ls -la ~/$VERIFY_FILE"; then
              echo "   ✅ Verification file creation: SUCCESS"
              echo "   📄 File created: ~/$VERIFY_FILE"
            else
              echo "   ❌ Verification file creation: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   └─ Testing file write permissions..."
            # Test file write permissions
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'Testing write permissions at $(date)' >> ~/$VERIFY_FILE && echo 'Write permissions test: SUCCESS'"; then
              echo "   ✅ File write permissions: SUCCESS"
            else
              echo "   ❌ File write permissions: FAILED"
              rm -f "$TEMP_KEY"
              exit 1
            fi
            
            echo "   └─ Displaying verification file contents..."
            # Display the verification file contents
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo '=== Verification File Contents ===' && cat ~/$VERIFY_FILE && echo '=== End of File ==='"; then
              echo "   ✅ File read access: SUCCESS"
            else
              echo "   ❌ File read access: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   └─ Testing SSH key authentication..."
            # Test SSH key authentication specifically
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o PasswordAuthentication=no $user@$EC2_IP "echo 'SSH key authentication successful for $user'"; then
              echo "   ✅ SSH key authentication: SUCCESS"
            else
              echo "   ❌ SSH key authentication: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            # Clean up temporary key
            rm -f "$TEMP_KEY"
            
            echo "🎉 User $user: ALL VERIFICATIONS PASSED ✅"
            echo "   └─ SSH access: ✅"
            echo "   └─ Home directory: ✅"
            echo "   └─ File creation: ✅"
            echo "   └─ Write permissions: ✅"
            echo "   └─ Read permissions: ✅"
            echo "   └─ Key authentication: ✅"
            echo ""
          done
          
          echo "🎊 VERIFICATION COMPLETE! 🎊"
          echo "✅ All users can access EC2 instance successfully"
          echo "✅ All users have proper file permissions"
          echo "✅ All users can create and read files"
          echo "✅ SSH key authentication working for all users"
          echo ""
          echo "📋 Verification Summary:"
          echo "- Total users verified: $(echo $USERS | wc -w)"
          echo "- Users: $USERS"
          echo "- Verification timestamp: $TIMESTAMP"
          echo "- All tests: PASSED ✅"
          
      - name: Create Terraform Variables (Simplified)
        run: |
          cd terraform
          echo "=== Creating Simplified Terraform Variables ==="
          
          # Create minimal terraform.tfvars for user provisioning
          # Note: instance_ids should be a list, not a string
          INSTANCE_IDS="${{ github.event.inputs.instance_ids }}"
          AWS_REGION="${{ inputs.aws_region }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          echo "instance_ids = [\"$INSTANCE_IDS\"]" > terraform.tfvars
          echo "aws_region = \"$AWS_REGION\"" >> terraform.tfvars
          echo "dry_run = $DRY_RUN" >> terraform.tfvars
          echo 'ssh_private_key_path = "~/.ssh/ec2-provisioning-key"' >> terraform.tfvars
          echo 'ssh_user = "ec2-user"' >> terraform.tfvars
          echo 'users_file = "../users.yaml"' >> terraform.tfvars
          
          echo "✅ terraform.tfvars created with proper formatting"
          echo "Contents of terraform.tfvars:"
          cat terraform.tfvars
          
      - name: Terraform Init
        run: |
          cd terraform
          echo "=== Terraform Initialization ==="
          terraform init
          echo "✅ Terraform initialized"
          
      - name: Terraform Plan
        run: |
          cd terraform
          echo "=== Terraform Plan ==="
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode"
            terraform plan -var-file="terraform.tfvars"
          else
            terraform plan -var-file="terraform.tfvars" -out=tfplan
          fi
          
          echo "✅ Terraform plan completed"
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true'
        run: |
          cd terraform
          echo "=== Terraform Apply ==="
          
          if [ -f "tfplan" ]; then
            terraform apply -auto-approve tfplan
            echo "✅ Terraform apply completed"
          else
            echo "❌ No plan file found"
            exit 1
          fi
          
      - name: Send SSH Keys via Email
        if: github.event.inputs.send_emails == 'true'
        run: |
          echo "=== Sending SSH Keys via Email (Python SMTP) ==="
          
          # Set SMTP configuration for UMB
          SMTP_HOST="mailhost.umb.com"
          SMTP_PORT="25"
          TEST_EMAIL="saran.alla@umb.com"
          
          echo "📧 SMTP Configuration:"
          echo "- Host: $SMTP_HOST"
          echo "- Port: $SMTP_PORT"
          echo "- Test Email: $TEST_EMAIL"
          echo ""
          
          # Create Python script for sending emails
          cat > /tmp/send_emails.py << 'EOF'
          import smtplib
          import yaml
          import os
          import sys
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from email.mime.application import MIMEApplication
          
          def send_ssh_key_email(username, full_name, user_email, instance_id, instance_ip, instance_name, smtp_host, smtp_port):
              """Send SSH key email using Python SMTP with multiple key formats as attachments"""
              
              # Create email message with multipart support
              msg = MIMEMultipart()
              msg['From'] = 'EC2-Provisioning <noreply@mailhost.umb.com>'
              msg['To'] = user_email
              msg['Subject'] = f'SSH Keys for EC2 Access - {username} (Multiple Formats)'
              
              # Create comprehensive email body with Windows and Linux instructions
              email_body = f"SSH Keys for EC2 Access - {username}\n"
              email_body += "==========================================\n\n"
              email_body += "User Information:\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Full Name: {full_name}\n"
              email_body += f"- Generated: {os.popen('date').read().strip()}\n\n"
              email_body += "Instance Details:\n"
              email_body += f"- Instance Name: {instance_name}\n"
              email_body += f"- Instance ID: {instance_id}\n"
              email_body += f"- IP Address: {instance_ip}\n"
              email_body += f"- SSH Port: 22\n\n"
              email_body += "🔑 MULTIPLE KEY FORMATS PROVIDED:\n"
              email_body += "================================\n\n"
              email_body += "1. {username}_private_key - Standard RSA private key (Linux/Mac/Windows OpenSSH)\n"
              email_body += "2. {username}_universal.pem - PEM format (works with most SSH clients)\n"
              email_body += "3. {username}_putty.ppk - PuTTY format (Windows PuTTY users)\n\n"
              email_body += "📋 WHICH KEY TO USE:\n"
              email_body += "===================\n\n"
              email_body += "🖥️  WINDOWS USERS (Recommended: PuTTY):\n"
              email_body += "   - Use: {username}_putty.ppk\n"
              email_body += "   - Download PuTTY: https://www.putty.org/\n"
              email_body += "   - Connection: Host: {instance_ip}, Port: 22, Username: {username}\n\n"
              email_body += "🖥️  WINDOWS USERS (Alternative: OpenSSH):\n"
              email_body += "   - Use: {username}_universal.pem\n"
              email_body += "   - Windows 10/11 built-in SSH client\n"
              email_body += "   - Command: ssh -i {username}_universal.pem {username}@{instance_ip}\n\n"
              email_body += "🐧 LINUX/MAC USERS:\n"
              email_body += "   - Use: {username}_private_key or {username}_universal.pem\n"
              email_body += "   - Command: ssh -i ~/.ssh/{username}_private_key {username}@{instance_ip}\n\n"
              email_body += "🔒 SECURITY IMPORTANT:\n"
              email_body += "====================\n"
              email_body += "- Keep private keys secure and never share them\n"
              email_body += "- Store keys in a secure directory\n"
              email_body += "- Never commit private keys to version control\n"
              email_body += "- Each key is unique to your user account\n\n"
              email_body += "📖 DETAILED SETUP INSTRUCTIONS:\n"
              email_body += "================================\n\n"
              email_body += "🖥️  WINDOWS SETUP (PuTTY - Recommended):\n"
              email_body += "1. Download and install PuTTY from https://www.putty.org/\n"
              email_body += "2. Open PuTTY\n"
              email_body += "3. Enter Host Name: {instance_ip}\n"
              email_body += "4. Set Port: 22\n"
              email_body += "5. Go to Connection > SSH > Auth > Credentials\n"
              email_body += "6. Browse and select: {username}_putty.ppk\n"
              email_body += "7. Go back to Session, enter a name and save\n"
              email_body += "8. Click Open and enter username: {username}\n\n"
              email_body += "🖥️  WINDOWS SETUP (OpenSSH - Alternative):\n"
              email_body += "1. Save {username}_universal.pem to C:\\Users\\{username}\\.ssh\\\n"
              email_body += "2. Open Command Prompt or PowerShell\n"
              email_body += "3. Run: ssh -i C:\\Users\\{username}\\.ssh\\{username}_universal.pem {username}@{instance_ip}\n\n"
              email_body += "🐧 LINUX/MAC SETUP:\n"
              email_body += "1. Save {username}_private_key to ~/.ssh/\n"
              email_body += "2. Set permissions: chmod 600 ~/.ssh/{username}_private_key\n"
              email_body += "3. Connect: ssh -i ~/.ssh/{username}_private_key {username}@{instance_ip}\n\n"
              email_body += "🔧 TROUBLESHOOTING:\n"
              email_body += "==================\n"
              email_body += "- Connection fails: Check IP address and username\n"
              email_body += "- Permission denied: Verify key file permissions\n"
              email_body += "- Key format error: Use the correct format for your SSH client\n"
              email_body += "- Network issues: Ensure you're connecting from an allowed network\n\n"
              email_body += "📞 CONNECTION SUMMARY:\n"
              email_body += "====================\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Instance: {instance_name} ({instance_id})\n"
              email_body += f"- IP Address: {instance_ip}\n"
              email_body += f"- PuTTY: Use {username}_putty.ppk file\n"
              email_body += f"- OpenSSH: ssh -i {username}_universal.pem {username}@{instance_ip}\n"
              email_body += f"- Linux/Mac: ssh -i {username}_private_key {username}@{instance_ip}\n\n"
              email_body += "This is an automated message from the AWS EC2 User Provisioning System.\n"
              email_body += "If you have questions, contact your system administrator.\n\n"
              email_body += "🎯 RECOMMENDATION: Windows users should use PuTTY with the .ppk file for the best experience."
              
              # Attach the email body
              msg.attach(MIMEText(email_body, 'plain', 'utf-8'))
              
              # Attach all three key formats
              # 1. Standard RSA private key
              if os.path.exists(f'/tmp/ssh_keys/{username}_private_key'):
                  with open(f'/tmp/ssh_keys/{username}_private_key', 'r') as f:
                      key_content = f.read()
                  key_attachment = MIMEApplication(key_content.encode('utf-8'), _subtype='txt')
                  key_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_private_key')
                  msg.attach(key_attachment)
              
              # 2. Universal PEM format
              if os.path.exists(f'/tmp/ssh_keys/{username}_universal.pem'):
                  with open(f'/tmp/ssh_keys/{username}_universal.pem', 'r') as f:
                      pem_content = f.read()
                  pem_attachment = MIMEApplication(pem_content.encode('utf-8'), _subtype='txt')
                  pem_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_universal.pem')
                  msg.attach(pem_attachment)
              
              # 3. PuTTY format (.ppk)
              if os.path.exists(f'/tmp/ssh_keys/{username}_putty.ppk'):
                  with open(f'/tmp/ssh_keys/{username}_putty.ppk', 'r') as f:
                      ppk_content = f.read()
                  ppk_attachment = MIMEApplication(ppk_content.encode('utf-8'), _subtype='txt')
                  ppk_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_putty.ppk')
                  msg.attach(ppk_attachment)
              
              try:
                  # Connect to SMTP server
                  print(f"📧 Connecting to SMTP server {smtp_host}:{smtp_port}...")
                  server = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
                  
                  # Start TLS if supported
                  try:
                      server.starttls()
                      print("✅ TLS connection established")
                  except:
                      print("ℹ️  TLS not supported, continuing without encryption")
                  
                  # Send email
                  print(f"📤 Sending email to {user_email} for user {username}...")
                  server.send_message(msg)
                  server.quit()
                  
                  print(f"✅ Email sent successfully for user {username} to {user_email}")
                  print(f"📎 Private key attached as: {username}_private_key")
                  return True
                  
              except Exception as e:
                  print(f"❌ Failed to send email for user {username} to {user_email}: {str(e)}")
                  return False
          
          def main():
              # Configuration
              smtp_host = os.environ.get('SMTP_HOST', 'mailhost.umb.com')
              smtp_port = int(os.environ.get('SMTP_PORT', '25'))
              
              # Get instance details from environment variables
              instance_id = os.environ.get('EC2_INSTANCE_ID', 'Unknown')
              instance_ip = os.environ.get('EC2_INSTANCE_IP', 'Unknown')
              instance_name = os.environ.get('EC2_INSTANCE_NAME', 'EC2 Instance')
              
              print(f"🏠 Instance Details:")
              print(f"   - ID: {instance_id}")
              print(f"   - IP: {instance_ip}")
              print(f"   - Name: {instance_name}")
              print()
              
              # Read user key status from the file created by the S3 step
              user_key_status = {}
              try:
                  with open('/tmp/user_key_status.txt', 'r') as f:
                      for line in f:
                          line = line.strip()
                          if ':' in line:
                              username, status = line.split(':', 1)
                              user_key_status[username] = status
                  print(f"📋 User key status loaded: {len(user_key_status)} users")
              except FileNotFoundError:
                  print("⚠️  User key status file not found, treating all users as new")
              except Exception as e:
                  print(f"⚠️  Error reading user key status: {e}")
              
              # Read users from users.yaml
              try:
                  with open('users.yaml', 'r') as f:
                      data = yaml.safe_load(f)
                      users = data['users']
                      print(f"📋 Found {len(users)} users to process")
                      print()
              except Exception as e:
                  print(f"❌ Error reading users.yaml: {e}")
                  return 1
              
              # Process each user
              success_count = 0
              total_count = len(users)
              new_users_count = 0
              existing_users_count = 0
              
              for user_data in users:
                  username = user_data['username']
                  full_name = user_data['full_name']
                  user_email = user_data.get('email')
                  
                  # Skip users without email addresses
                  if not user_email:
                      print(f"⚠️  Skipping user {username} - no email address found")
                      continue
                  
                  # Check if this user is new or existing based on key status
                  user_status = user_key_status.get(username, 'new')  # Default to 'new' if status unknown
                  
                  if user_status == 'existing':
                      print(f"ℹ️  User {username} ({full_name}) - Existing key preserved, skipping email")
                      existing_users_count += 1
                      continue
                  elif user_status == 'new':
                      print(f"🆕 User {username} ({full_name}) - New key generated, sending email to {user_email}")
                      new_users_count += 1
                  else:
                      print(f"❓ User {username} ({full_name}) - Unknown status '{user_status}', treating as new user")
                      new_users_count += 1
                  
                  # Check if key files exist
                  key_files_exist = True
                  required_files = [
                      f"/tmp/ssh_keys/{username}_private_key",
                      f"/tmp/ssh_keys/{username}_universal.pem"
                  ]
                  
                  for key_file in required_files:
                      if not os.path.exists(key_file):
                          print(f"⚠️  Required key file not found: {key_file}")
                          key_files_exist = False
                          break
                  
                  if not key_files_exist:
                      print(f"⚠️  Missing required key files for {username}")
                      continue
                  
                  print(f"✅ All key formats available for {username}")
                  
                  # Send email only to new users
                  if send_ssh_key_email(username, full_name, user_email, 
                                     instance_id, instance_ip, instance_name,
                                     smtp_host, smtp_port):
                      success_count += 1
                      print(f"📧 Email sent to {user_email} for user {username}")
                  else:
                      print(f"❌ Failed to send email for user {username}")
                  
                  print()
              
              # Summary
              print("=== Email Delivery Summary ===")
              print(f"Total users processed: {total_count}")
              print(f"New users (emails sent): {new_users_count}")
              print(f"Existing users (no emails): {existing_users_count}")
              print(f"Emails sent successfully: {success_count}")
              print(f"Emails failed: {new_users_count - success_count}")
              print()
              
              if success_count > 0:
                  print(f"✅ SSH keys processed successfully for {success_count} new users")
                  print(f"📧 Only new users received emails with their keys")
                  print(f"ℹ️  Existing users maintained their access without emails")
                  return 0
              else:
                  print("❌ No emails were processed successfully")
                  return 1
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Set environment variables for Python script
          export SMTP_HOST="$SMTP_HOST"
          export SMTP_PORT="$SMTP_PORT"
          export EC2_INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"
          export EC2_INSTANCE_IP="${{ env.EC2_INSTANCE_IP }}"
          export EC2_INSTANCE_NAME="EC2 Instance"
          
          # Try to get instance name from AWS if available
          if command -v aws &> /dev/null && [ -n "${{ env.EC2_INSTANCE_ID }}" ]; then
            echo "🔍 Getting instance details from AWS..."
            instance_name=$(aws ec2 describe-instances --instance-ids "${{ env.EC2_INSTANCE_ID }}" --query 'Reservations[0].Instances[0].Tags[?Key==`Name`].Value' --output text 2>/dev/null || echo "EC2 Instance")
            export EC2_INSTANCE_NAME="$instance_name"
            echo "✅ Instance name: $instance_name"
          fi
          
          # Run Python script
          echo "🐍 Running Python SMTP script..."
          python3 /tmp/send_emails.py
          
          # Clean up
          rm -f /tmp/send_emails.py
          
          echo ""
          echo "📧 Email Summary:"
          echo "- SMTP Server: $SMTP_HOST:$SMTP_PORT"
          echo "- Each user receives their SSH key at their own email address"
          echo "- Python SMTP implementation completed"
          
      - name: Cleanup
        run: |
          echo "=== Cleanup ==="
          rm -rf /tmp/ssh_keys
          echo "✅ Temporary files cleaned up"
          
      - name: Success Summary
        run: |
          echo ""
          echo "🎉 USER PROVISIONING COMPLETED SUCCESSFULLY! 🎉"
          echo ""
          echo "📋 Summary:"
          echo "- EC2 Instance: ${{ env.EC2_INSTANCE_ID }}"
          echo "- IP Address: ${{ env.EC2_INSTANCE_IP }} (${{ env.EC2_IP_TYPE }} IP)"
          echo "- Users Created: $USERS"
          echo "- SSH Keys: Available in S3 bucket and sent via email"
          echo "- Access Verified: All users can SSH to EC2"
          echo ""
          echo "🔍 Verification Details:"
          echo "- Verification Timestamp: $(date +"%Y%m%d-%H%M%S")"
          echo "- Verification Files Created: user_verification_*.txt in each user's home directory"
          echo "- All Users Tested: SSH access, file creation, read/write permissions, key authentication"
          echo ""
          echo "✅ Verification Results:"
          echo "- SSH Access: All users can connect successfully"
          echo "- File Operations: All users can create, read, and write files"
          echo "- Permissions: All users have proper home directory access"
          echo "- Authentication: SSH key-based authentication working for all users"
          echo ""
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "📧 Email Delivery:"
            echo "- Each user received their SSH private key at their own email address"
            echo "- SMTP Server: mailhost.umb.com:25"
            echo "- Keys delivered: 6 private keys with instructions"
            echo ""
          fi
          echo "🔑 Next Steps:"
          echo "1. SSH keys available in S3 bucket: ec2-user-provisioning-keys"
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "2. Check email at your own email address for SSH keys"
          fi
          echo "3. Users connect: ssh -i user_key user@${{ env.EC2_INSTANCE_IP }}"
          echo "4. All users have full access to their home directories"
          echo "5. Verification files created: ~/user_verification_*.txt"
          echo ""
          echo "🎯 No manual verification needed - all tests passed automatically!"

 