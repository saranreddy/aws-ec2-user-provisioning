name: Provision Users on AWS EC2 Instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Select EC2 instance ID from the dropdown'
        required: true
        type: choice
        options:
          - i-0d2ea774d38f88fe2
          - i-059108826eb667a3d
          - i-03810d57b29eff7fa
          - i-04f6cf69514fab8ec
          - i-069c4707f66eee735
          - i-038146dc9a729c973
          - i-0ce61b84050ece568
          - i-0079b3bcbc7b9c83e
          - i-0a6b63f03c28c1336
          - i-019d6e26b39617852
          - i-00ca906185f13e772
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1
      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean

env:
  TF_VERSION: "1.5.7"

jobs:
  provision-users:
    name: Provision Users on EC2 Instances
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "‚ùå Required secret 'aws_ec2_creation_role' is not set"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          echo "=== AWS Credentials Verification ==="
          aws sts get-caller-identity
          echo "‚úÖ AWS credentials verified"
          
      - name: Setup SSH Key for EC2 Access
        run: |
          echo "=== Setting up SSH Key for EC2 Access ==="
          
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Required secret 'EC2_SSH_PRIVATE_KEY' is not set"
            exit 1
          fi
          
          # Create .ssh directory and key file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
          chmod 600 ~/.ssh/ec2-provisioning-key
          
          echo "‚úÖ SSH key file created at ~/.ssh/ec2-provisioning-key"
          
      - name: Get EC2 Instance Details
        run: |
          echo "=== Getting EC2 Instance Details ==="
          
          INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
          REGION="${{ inputs.aws_region }}"
          
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --region $REGION \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          # Try to get public IP first, fall back to private IP if public is not available
          PUBLIC_IP=$(echo $INSTANCE_INFO | jq -r '.PublicIpAddress')
          PRIVATE_IP=$(echo $INSTANCE_INFO | jq -r '.PrivateIpAddress')
          
          if [ "$PUBLIC_IP" != "null" ] && [ -n "$PUBLIC_IP" ]; then
            echo "‚úÖ Using public IP for instance $INSTANCE_ID"
            INSTANCE_IP="$PUBLIC_IP"
            IP_TYPE="public"
          elif [ "$PRIVATE_IP" != "null" ] && [ -n "$PRIVATE_IP" ]; then
            echo "‚úÖ Using private IP for instance $INSTANCE_ID (public IP not available)"
            INSTANCE_IP="$PRIVATE_IP"
            IP_TYPE="private"
          else
            echo "‚ùå Could not get IP address for instance $INSTANCE_ID"
            echo "Instance info: $INSTANCE_INFO"
              exit 1
            fi
          
          echo "Instance ID: $INSTANCE_ID"
          echo "IP Address: $INSTANCE_IP ($IP_TYPE)"
          echo "Region: $REGION"
          
          # Store for later use
          echo "EC2_INSTANCE_IP=$INSTANCE_IP" >> $GITHUB_ENV
          echo "EC2_INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "EC2_IP_TYPE=$IP_TYPE" >> $GITHUB_ENV
          
          echo "‚úÖ EC2 instance details retrieved"
          
      - name: Generate SSH Keys
        run: |
          echo "=== Generating SSH Keys ==="
          
          # Create temporary directory for keys
          mkdir -p /tmp/ssh_keys
          chmod 755 /tmp/ssh_keys
          
          # Read usernames from users.yaml dynamically
          echo "Reading users from users.yaml..."
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "Users found: $USERS"
          
          # Generate SSH keys for all users
          for user in $USERS; do
            echo "Generating keys for user: $user"
            
              if ssh-keygen -t rsa -b 4096 \
                -f /tmp/ssh_keys/${user}_key \
                -N "" \
              -C "${user}@ec2-provisioning-$(date +%Y%m%d-%H%M%S)"; then
                
                # Rename files for clarity
                mv /tmp/ssh_keys/${user}_key /tmp/ssh_keys/${user}_private_key
                mv /tmp/ssh_keys/${user}_key.pub /tmp/ssh_keys/${user}_public_key
              echo "‚úÖ Generated keys for $user"
                else
                  echo "‚ùå Failed to generate keys for $user"
                  exit 1
            fi
          done
          
          echo "‚úÖ All SSH keys generated successfully"
          
      - name: Upload SSH Keys to S3
        run: |
          echo "=== Uploading SSH Keys to S3 ==="
          
          # Create S3 bucket for key storage
          BUCKET_NAME="ec2-user-provisioning-$(date +%Y%m%d-%H%M%S)"
          aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }}
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          # Upload keys to S3
          for user in $USERS; do
            aws s3 cp /tmp/ssh_keys/${user}_private_key s3://$BUCKET_NAME/keys/${user}_private_key --sse AES256
            aws s3 cp /tmp/ssh_keys/${user}_public_key s3://$BUCKET_NAME/keys/${user}_public_key --sse AES256
            echo "‚úÖ Uploaded keys for $user to S3"
          done
          
          echo "‚úÖ All keys uploaded to S3 bucket: $BUCKET_NAME"
          
      - name: Install SSH Keys on EC2 Instance
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Installing SSH Keys on EC2 Instance ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          SSH_USER="ec2-user"
          
          echo "Connecting to EC2 instance at $EC2_IP (${{ env.EC2_IP_TYPE }} IP)..."
          
          # Test SSH connection first
          if ssh -i ~/.ssh/ec2-provisioning-key -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SSH_USER@$EC2_IP "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection established"
          else
            echo "‚ùå Failed to establish SSH connection"
              exit 1
            fi
          
          # Make the script executable
          chmod +x scripts/install_users.sh
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          # Install each user's public key using the script
          for user in $USERS; do
            if [ -f "/tmp/ssh_keys/${user}_public_key" ]; then
              echo "Installing key for user: $user"
              
              # Read the public key content
              PUBLIC_KEY=$(cat "/tmp/ssh_keys/${user}_public_key")
              
              # Call the user provisioning script
              echo "Running user provisioning script for $user..."
              if ./scripts/install_users.sh "$user" "$PUBLIC_KEY" "$SSH_USER" "$EC2_IP"; then
                echo "‚úÖ User $user provisioned successfully"
              else
                echo "‚ùå Failed to provision user $user"
              exit 1
              fi
            else
              echo "‚ùå SSH key for $user not found"
              exit 1
            fi
          done
          
          echo "‚úÖ All SSH keys installed on EC2 instance"
          
      - name: Verify User Access
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Verifying User Access ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          
          echo "üîç Verification Details:"
          echo "- EC2 Instance IP: $EC2_IP"
          echo "- Verification Timestamp: $TIMESTAMP"
          echo "- Total Users to Verify: $(echo $USERS | wc -w)"
          echo ""
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "üìã Users to verify: $USERS"
            echo ""
          
          # Test each user's SSH access with comprehensive verification
          for user in $USERS; do
            echo "üß™ Testing SSH access for user: $user"
            echo "   ‚îî‚îÄ Creating temporary key file..."
            
            # Create a temporary private key file for testing
            TEMP_KEY="/tmp/test_${user}_key"
            cp "/tmp/ssh_keys/${user}_private_key" "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"
            
            echo "   ‚îî‚îÄ Testing basic SSH connection..."
            # Test basic SSH connection
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o ConnectTimeout=10 $user@$EC2_IP "echo '‚úÖ Basic SSH connection successful for $user'"; then
              echo "   ‚úÖ Basic SSH connection: SUCCESS"
            else
              echo "   ‚ùå Basic SSH connection: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing user identity and home directory..."
            # Test user identity and home directory access
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "whoami && pwd && echo 'Home directory contents:' && ls -la"; then
              echo "   ‚úÖ User identity and home directory: SUCCESS"
            else
              echo "   ‚ùå User identity and home directory: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Creating verification file in user's home directory..."
            # Create a verification file in the user's home directory
            VERIFY_FILE="user_verification_${TIMESTAMP}.txt"
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'User $user successfully logged in at $(date)' > ~/$VERIFY_FILE && echo 'Verification file created successfully' && ls -la ~/$VERIFY_FILE"; then
              echo "   ‚úÖ Verification file creation: SUCCESS"
              echo "   üìÑ File created: ~/$VERIFY_FILE"
            else
              echo "   ‚ùå Verification file creation: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing file write permissions..."
            # Test file write permissions
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'Testing write permissions at $(date)' >> ~/$VERIFY_FILE && echo 'Write permissions test: SUCCESS'"; then
              echo "   ‚úÖ File write permissions: SUCCESS"
            else
              echo "   ‚ùå File write permissions: FAILED"
              rm -f "$TEMP_KEY"
              exit 1
            fi
            
            echo "   ‚îî‚îÄ Displaying verification file contents..."
            # Display the verification file contents
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo '=== Verification File Contents ===' && cat ~/$VERIFY_FILE && echo '=== End of File ==='"; then
              echo "   ‚úÖ File read access: SUCCESS"
            else
              echo "   ‚ùå File read access: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing SSH key authentication..."
            # Test SSH key authentication specifically
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o PasswordAuthentication=no $user@$EC2_IP "echo 'SSH key authentication successful for $user'"; then
              echo "   ‚úÖ SSH key authentication: SUCCESS"
            else
              echo "   ‚ùå SSH key authentication: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            # Clean up temporary key
            rm -f "$TEMP_KEY"
            
            echo "üéâ User $user: ALL VERIFICATIONS PASSED ‚úÖ"
            echo "   ‚îî‚îÄ SSH access: ‚úÖ"
            echo "   ‚îî‚îÄ Home directory: ‚úÖ"
            echo "   ‚îî‚îÄ File creation: ‚úÖ"
            echo "   ‚îî‚îÄ Write permissions: ‚úÖ"
            echo "   ‚îî‚îÄ Read permissions: ‚úÖ"
            echo "   ‚îî‚îÄ Key authentication: ‚úÖ"
            echo ""
          done
          
          echo "üéä VERIFICATION COMPLETE! üéä"
          echo "‚úÖ All users can access EC2 instance successfully"
          echo "‚úÖ All users have proper file permissions"
          echo "‚úÖ All users can create and read files"
          echo "‚úÖ SSH key authentication working for all users"
          echo ""
          echo "üìã Verification Summary:"
          echo "- Total users verified: $(echo $USERS | wc -w)"
          echo "- Users: $USERS"
          echo "- Verification timestamp: $TIMESTAMP"
          echo "- All tests: PASSED ‚úÖ"
          
      - name: Create Terraform Variables (Simplified)
        run: |
          cd terraform
          echo "=== Creating Simplified Terraform Variables ==="
          
          # Create minimal terraform.tfvars for user provisioning
          # Note: instance_ids should be a list, not a string
          INSTANCE_IDS="${{ github.event.inputs.instance_ids }}"
          AWS_REGION="${{ inputs.aws_region }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          echo "instance_ids = [\"$INSTANCE_IDS\"]" > terraform.tfvars
          echo "aws_region = \"$AWS_REGION\"" >> terraform.tfvars
          echo "dry_run = $DRY_RUN" >> terraform.tfvars
          echo 'ssh_private_key_path = "~/.ssh/ec2-provisioning-key"' >> terraform.tfvars
          echo 'ssh_user = "ec2-user"' >> terraform.tfvars
          echo 'users_file = "../users.yaml"' >> terraform.tfvars
          
          echo "‚úÖ terraform.tfvars created with proper formatting"
          echo "Contents of terraform.tfvars:"
          cat terraform.tfvars
          
      - name: Terraform Init
        run: |
          cd terraform
          echo "=== Terraform Initialization ==="
          terraform init
          echo "‚úÖ Terraform initialized"
          
      - name: Terraform Plan
        run: |
          cd terraform
          echo "=== Terraform Plan ==="
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode"
            terraform plan -var-file="terraform.tfvars"
          else
            terraform plan -var-file="terraform.tfvars" -out=tfplan
          fi
          
          echo "‚úÖ Terraform plan completed"
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true'
        run: |
          cd terraform
          echo "=== Terraform Apply ==="
          
          if [ -f "tfplan" ]; then
            terraform apply -auto-approve tfplan
            echo "‚úÖ Terraform apply completed"
          else
            echo "‚ùå No plan file found"
            exit 1
          fi
          
      - name: Send SSH Keys via Email
        if: github.event.inputs.send_emails == 'true'
        run: |
          echo "=== Sending SSH Keys via Email (Python SMTP) ==="
          
          # Set SMTP configuration for UMB
          SMTP_HOST="mailhost.umb.com"
          SMTP_PORT="25"
          TEST_EMAIL="saran.alla@umb.com"
          
          echo "üìß SMTP Configuration:"
          echo "- Host: $SMTP_HOST"
          echo "- Port: $SMTP_PORT"
          echo "- Test Email: $TEST_EMAIL"
          echo ""
          
          # Create Python script for sending emails
          cat > /tmp/send_emails.py << 'EOF'
          import smtplib
          import yaml
          import os
          import sys
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from email.mime.application import MIMEApplication
          
          def send_ssh_key_email(username, full_name, private_key_content, instance_id, instance_ip, instance_name, smtp_host, smtp_port, recipient_email):
              """Send SSH key email using Python SMTP with private key as attachment"""
              
              # Create email message with multipart support
              msg = MIMEMultipart()
              msg['From'] = 'EC2-Provisioning <noreply@mailhost.umb.com>'
              msg['To'] = recipient_email
              msg['Subject'] = f'SSH Key for EC2 Access - {username}'
              
              # Create email body (without the private key content)
              email_body = f"SSH Key for EC2 Access - {username}\n"
              email_body += "==========================================\n\n"
              email_body += "User Information:\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Full Name: {full_name}\n"
              email_body += f"- Generated: {os.popen('date').read().strip()}\n\n"
              email_body += "Instance Details:\n"
              email_body += f"- Instance Name: {instance_name}\n"
              email_body += f"- Instance ID: {instance_id}\n"
              email_body += f"- Private IP: {instance_ip}\n"
              email_body += f"- Connection IP: {instance_ip}\n\n"
              email_body += "Your SSH private key has been generated and is attached to this email.\n"
              email_body += "Use this key to access your EC2 instance.\n\n"
              email_body += "SECURITY IMPORTANT:\n"
              email_body += "- Keep this private key secure and never share it\n"
              email_body += "- Store it in ~/.ssh/ directory\n"
              email_body += "- Set proper permissions: chmod 600 your_key_file\n"
              email_body += "- Never commit private keys to version control\n"
              email_body += "- This key is unique to your user account\n\n"
              email_body += "USAGE INSTRUCTIONS:\n"
              email_body += "==================\n\n"
              email_body += "Step 1: Save the Private Key\n"
              email_body += f"- Download the attached private key file: {username}_private_key\n"
              email_body += "- Save it to your ~/.ssh/ directory\n"
              email_body += f"- Example: mkdir -p ~/.ssh && save the attachment as ~/.ssh/{username}_key\n\n"
              email_body += "Step 2: Set Proper Permissions\n"
              email_body += f"- Set restrictive permissions: chmod 600 ~/.ssh/{username}_key\n"
              email_body += f"- Verify permissions: ls -la ~/.ssh/{username}_key\n\n"
              email_body += "Step 3: Connect to EC2 Instance\n"
              email_body += f"- Use this command: ssh -i ~/.ssh/{username}_key {username}@{instance_ip}\n"
              email_body += f"- Example: ssh -i ~/.ssh/{username}_key {username}@{instance_ip}\n\n"
              email_body += "Step 4: Verify Connection\n"
              email_body += "- You should see a welcome message\n"
              email_body += "- Run 'whoami' to confirm your username\n"
              email_body += "- Run 'pwd' to see your home directory\n\n"
              email_body += "Troubleshooting:\n"
              email_body += "- If connection fails, check your private key file\n"
              email_body += "- Ensure permissions are correct (chmod 600)\n"
              email_body += "- Verify the instance IP address is correct\n"
              email_body += "- Check if you're connecting from an allowed network\n\n"
              email_body += "Connection Summary:\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Instance: {instance_name} ({instance_id})\n"
              email_body += f"- IP Address: {instance_ip}\n"
              email_body += f"- SSH Command: ssh -i ~/.ssh/{username}_key {username}@{instance_ip}\n\n"
              email_body += "This is an automated message from the AWS EC2 User Provisioning System.\n"
              email_body += "If you have any questions or need assistance, please contact your system administrator."
              
              # Attach the email body
              msg.attach(MIMEText(email_body, 'plain', 'utf-8'))
              
              # Attach the private key as a file
              key_attachment = MIMEApplication(private_key_content.encode('utf-8'), _subtype='txt')
              key_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_private_key')
              msg.attach(key_attachment)
              
              try:
                  # Connect to SMTP server
                  print(f"üìß Connecting to SMTP server {smtp_host}:{smtp_port}...")
                  server = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
                  
                  # Start TLS if supported
                  try:
                      server.starttls()
                      print("‚úÖ TLS connection established")
                  except:
                      print("‚ÑπÔ∏è  TLS not supported, continuing without encryption")
                  
                  # Send email
                  print(f"üì§ Sending email to {recipient_email}...")
                  server.send_message(msg)
                  server.quit()
                  
                  print(f"‚úÖ Email sent successfully for user {username}")
                  print(f"üìé Private key attached as: {username}_private_key")
                  return True
                  
              except Exception as e:
                  print(f"‚ùå Failed to send email for user {username}: {str(e)}")
                  return False
          
          def main():
              # Configuration
              smtp_host = os.environ.get('SMTP_HOST', 'mailhost.umb.com')
              smtp_port = int(os.environ.get('SMTP_PORT', '25'))
              recipient_email = os.environ.get('TEST_EMAIL', 'saran.alla@umb.com')
              
              # Get instance details from environment variables
              instance_id = os.environ.get('EC2_INSTANCE_ID', 'Unknown')
              instance_ip = os.environ.get('EC2_INSTANCE_IP', 'Unknown')
              instance_name = os.environ.get('EC2_INSTANCE_NAME', 'EC2 Instance')
              
              print(f"üè† Instance Details:")
              print(f"   - ID: {instance_id}")
              print(f"   - IP: {instance_ip}")
              print(f"   - Name: {instance_name}")
              print()
              
              # Read users from users.yaml
              try:
                  with open('users.yaml', 'r') as f:
                      data = yaml.safe_load(f)
                      users = data['users']
                      print(f"üìã Found {len(users)} users to process")
                      print()
              except Exception as e:
                  print(f"‚ùå Error reading users.yaml: {e}")
                  return 1
              
              # Process each user
              success_count = 0
              total_count = len(users)
              
              for user_data in users:
                  username = user_data['username']
                  full_name = user_data['full_name']
                  
                  print(f"üß™ Processing user: {username} ({full_name})")
                  
                  # Check if key file exists
                  key_file = f"/tmp/ssh_keys/{username}_private_key"
                  if not os.path.exists(key_file):
                      print(f"‚ö†Ô∏è  No key file found for {username}")
                      continue
                  
                  # Read private key content
                  try:
                      with open(key_file, 'r') as f:
                          private_key_content = f.read().strip()
                      print(f"‚úÖ Private key loaded ({len(private_key_content)} characters)")
                  except Exception as e:
                      print(f"‚ùå Error reading key file: {e}")
                      continue
                  
                  # Send email
                  if send_ssh_key_email(username, full_name, private_key_content, 
                                     instance_id, instance_ip, instance_name,
                                     smtp_host, smtp_port, recipient_email):
                      success_count += 1
                  
                  print()
              
              # Summary
              print("=== Email Delivery Summary ===")
              print(f"Total users processed: {total_count}")
              print(f"Emails sent successfully: {success_count}")
              print(f"Emails failed: {total_count - success_count}")
              print()
              
              if success_count > 0:
                  print(f"‚úÖ SSH keys processed successfully for {success_count} users")
                  print(f"üìß Check your email at {recipient_email} for SSH key delivery")
                  return 0
              else:
                  print("‚ùå No emails were processed successfully")
                  return 1
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Set environment variables for Python script
          export SMTP_HOST="$SMTP_HOST"
          export SMTP_PORT="$SMTP_PORT"
          export TEST_EMAIL="$TEST_EMAIL"
          export EC2_INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"
          export EC2_INSTANCE_IP="${{ env.EC2_INSTANCE_IP }}"
          export EC2_INSTANCE_NAME="EC2 Instance"
          
          # Try to get instance name from AWS if available
          if command -v aws &> /dev/null && [ -n "${{ env.EC2_INSTANCE_ID }}" ]; then
            echo "üîç Getting instance details from AWS..."
            instance_name=$(aws ec2 describe-instances --instance-ids "${{ env.EC2_INSTANCE_ID }}" --query 'Reservations[0].Instances[0].Tags[?Key==`Name`].Value' --output text 2>/dev/null || echo "EC2 Instance")
            export EC2_INSTANCE_NAME="$instance_name"
            echo "‚úÖ Instance name: $instance_name"
          fi
          
          # Run Python script
          echo "üêç Running Python SMTP script..."
          python3 /tmp/send_emails.py
          
          # Clean up
          rm -f /tmp/send_emails.py
          
          echo ""
          echo "üìß Email Summary:"
          echo "- SMTP Server: $SMTP_HOST:$SMTP_PORT"
          echo "- Test Email: $TEST_EMAIL"
          echo "- Python SMTP implementation completed"
          
      - name: Cleanup
        run: |
          echo "=== Cleanup ==="
          rm -rf /tmp/ssh_keys
          echo "‚úÖ Temporary files cleaned up"
          
      - name: Success Summary
        run: |
          echo ""
          echo "üéâ USER PROVISIONING COMPLETED SUCCESSFULLY! üéâ"
          echo ""
          echo "üìã Summary:"
          echo "- EC2 Instance: ${{ env.EC2_INSTANCE_ID }}"
          echo "- IP Address: ${{ env.EC2_INSTANCE_IP }} (${{ env.EC2_IP_TYPE }} IP)"
          echo "- Users Created: $USERS"
          echo "- SSH Keys: Available in S3 bucket and sent via email"
          echo "- Access Verified: All users can SSH to EC2"
          echo ""
          echo "üîç Verification Details:"
          echo "- Verification Timestamp: $(date +"%Y%m%d-%H%M%S")"
          echo "- Verification Files Created: user_verification_*.txt in each user's home directory"
          echo "- All Users Tested: SSH access, file creation, read/write permissions, key authentication"
          echo ""
          echo "‚úÖ Verification Results:"
          echo "- SSH Access: All users can connect successfully"
          echo "- File Operations: All users can create, read, and write files"
          echo "- Permissions: All users have proper home directory access"
          echo "- Authentication: SSH key-based authentication working for all users"
          echo ""
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "üìß Email Delivery:"
            echo "- All SSH private keys sent to: saran.alla@umb.com (testing)"
            echo "- SMTP Server: mailhost.umb.com:25"
            echo "- Keys delivered: 6 private keys with instructions"
            echo ""
          fi
          echo "üîë Next Steps:"
          echo "1. SSH keys available in S3 bucket: $BUCKET_NAME"
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "2. Check email at saran.alla@umb.com for SSH keys"
          fi
          echo "3. Users connect: ssh -i user_key user@${{ env.EC2_INSTANCE_IP }}"
          echo "4. All users have full access to their home directories"
          echo "5. Verification files created: ~/user_verification_*.txt"
          echo ""
          echo "üéØ No manual verification needed - all tests passed automatically!"

 