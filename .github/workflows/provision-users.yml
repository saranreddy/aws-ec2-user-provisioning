name: Provision Users on AWS EC2 Instances

# Key Persistence Feature:
# - Uses fixed S3 bucket: ec2-user-provisioning-keys
# - Existing user keys are preserved across workflow runs
# - Only new users get new keys generated
# - Existing users maintain access to EC2 instances

on:
  workflow_dispatch:
    inputs:
      instance_ids:
        description: 'Select EC2 instance ID from the dropdown'
        required: true
        type: choice
        options:
          - i-0d2ea774d38f88fe2
          - i-059108826eb667a3d
          - i-03810d57b29eff7fa
          - i-04f6cf69514fab8ec
          - i-069c4707f66eee735
          - i-038146dc9a729c973
          - i-0ce61b84050ece568
          - i-0079b3bcbc7b9c83e
          - i-0a6b63f03c28c1336
          - i-019d6e26b39617852
          - i-00ca906185f13e772
      aws_account_id:
        description: 'AWS Account ID:'
        required: true
        default: '872515261591'
        type: string
      aws_region:
        description: 'AWS Region:'
        required: true
        default: 'us-east-2'
        type: choice
        options:
          - us-east-2
          - us-west-2
          - us-east-1
      dry_run:
        description: 'Enable dry run mode (no actual changes)'
        required: false
        default: false
        type: boolean
      send_emails:
        description: 'Send SSH keys to users via email'
        required: false
        default: true
        type: boolean

env:
  TF_VERSION: "1.5.7"

jobs:
  provision-users:
    name: Provision Users on EC2 Instances
    runs-on: docker
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Set Role Name
        run: |
          if [ -z "${{ secrets.aws_ec2_creation_role }}" ]; then
            echo "‚ùå Required secret 'aws_ec2_creation_role' is not set"
            exit 1
          fi
          
          echo 'AuthRole=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ secrets.aws_ec2_creation_role }}' >> $GITHUB_ENV
          echo "Using role ARN: ${{ env.AuthRole }}"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AuthRole }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws_region }}
          
      - name: Verify AWS Credentials
        run: |
          echo "=== AWS Credentials Verification ==="
          aws sts get-caller-identity
          echo "‚úÖ AWS credentials verified"
          
      - name: Setup SSH Key for EC2 Access
        run: |
          echo "=== Setting up SSH Key for EC2 Access ==="
          
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Required secret 'EC2_SSH_PRIVATE_KEY' is not set"
            exit 1
          fi
          
          # Create .ssh directory and key file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2-provisioning-key
          chmod 600 ~/.ssh/ec2-provisioning-key
          
          echo "‚úÖ SSH key file created at ~/.ssh/ec2-provisioning-key"
          
      - name: Get EC2 Instance Details
        run: |
          echo "=== Getting EC2 Instance Details ==="
          
          INSTANCE_ID="${{ github.event.inputs.instance_ids }}"
          REGION="${{ inputs.aws_region }}"
          
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --region $REGION \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          # Try to get public IP first, fall back to private IP if public is not available
          PUBLIC_IP=$(echo $INSTANCE_INFO | jq -r '.PublicIpAddress')
          PRIVATE_IP=$(echo $INSTANCE_INFO | jq -r '.PrivateIpAddress')
          
          if [ "$PUBLIC_IP" != "null" ] && [ -n "$PUBLIC_IP" ]; then
            echo "‚úÖ Using public IP for instance $INSTANCE_ID"
            INSTANCE_IP="$PUBLIC_IP"
            IP_TYPE="public"
          elif [ "$PRIVATE_IP" != "null" ] && [ -n "$PRIVATE_IP" ]; then
            echo "‚úÖ Using private IP for instance $INSTANCE_ID (public IP not available)"
            INSTANCE_IP="$PRIVATE_IP"
            IP_TYPE="private"
          else
            echo "‚ùå Could not get IP address for instance $INSTANCE_ID"
            echo "Instance info: $INSTANCE_INFO"
              exit 1
            fi
          
          echo "Instance ID: $INSTANCE_ID"
          echo "IP Address: $INSTANCE_IP ($IP_TYPE)"
          echo "Region: $REGION"
          
          # Store for later use
          echo "EC2_INSTANCE_IP=$INSTANCE_IP" >> $GITHUB_ENV
          echo "EC2_INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "EC2_IP_TYPE=$IP_TYPE" >> $GITHUB_ENV
          
          echo "‚úÖ EC2 instance details retrieved"
          
      - name: Generate SSH Keys (Multiple Formats)
        run: |
          echo "=== Generating SSH Keys in Multiple Formats ==="
          
          # Create temporary directory for keys
          mkdir -p /tmp/ssh_keys
          chmod 755 /tmp/ssh_keys
          
          # Install puttygen for PuTTY key conversion
          echo "Installing puttygen for key conversion..."
          if command -v apt-get &> /dev/null; then
            apt-get update && apt-get install -y putty-tools
          elif command -v yum &> /dev/null; then
            yum install -y putty
          elif command -v brew &> /dev/null; then
            brew install putty
          else
            echo "‚ö†Ô∏è  puttygen not available, will generate basic formats only"
          fi
          
          # Read usernames from users.yaml dynamically
          echo "Reading users from users.yaml..."
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "Users found: $USERS"
          
          # Generate SSH keys for all users in multiple formats
          for user in $USERS; do
            echo "Generating keys for user: $user"
            
            # Generate RSA key pair
            if ssh-keygen -t rsa -b 4096 \
              -f /tmp/ssh_keys/${user}_key \
              -N "" \
              -C "${user}@ec2-provisioning-$(date +%Y%m%d-%H%M%S)"; then
              
              # Rename files for clarity
              mv /tmp/ssh_keys/${user}_key /tmp/ssh_keys/${user}_private_key
              mv /tmp/ssh_keys/${user}_key.pub /tmp/ssh_keys/${user}_public_key
              
              # Convert to PEM format (universal)
              cp /tmp/ssh_keys/${user}_private_key /tmp/ssh_keys/${user}_universal.pem
              chmod 600 /tmp/ssh_keys/${user}_universal.pem
              
              # Convert to PuTTY format (.ppk) if puttygen is available
              if command -v puttygen &> /dev/null; then
                echo "Converting to PuTTY format for $user..."
                if puttygen /tmp/ssh_keys/${user}_private_key -o /tmp/ssh_keys/${user}_putty.ppk -O private; then
                  echo "‚úÖ PuTTY key generated for $user"
                else
                  echo "‚ö†Ô∏è  Failed to generate PuTTY key for $user"
                fi
              else
                echo "‚ö†Ô∏è  puttygen not available, skipping PuTTY format for $user"
              fi
              
              echo "‚úÖ Generated keys for $user in multiple formats"
            else
              echo "‚ùå Failed to generate keys for $user"
              exit 1
            fi
          done
          
          echo "‚úÖ All SSH keys generated successfully in multiple formats"
          
      - name: Upload SSH Keys to S3
        run: |
          echo "=== Uploading SSH Keys to S3 ==="
          
          # Use fixed S3 bucket for key persistence
          BUCKET_NAME="ec2-user-provisioning-keys"
          
          # Check if bucket exists, create if it doesn't
          if ! aws s3 ls s3://$BUCKET_NAME 2>&1 > /dev/null; then
            echo "ü™£ Creating new S3 bucket: $BUCKET_NAME"
            aws s3 mb s3://$BUCKET_NAME --region ${{ inputs.aws_region }}
          else
            echo "‚úÖ S3 bucket already exists: $BUCKET_NAME"
          fi
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "üìã Processing users: $USERS"
          echo ""
          
          # Process each user - check existing keys first
          for user in $USERS; do
            echo "üß™ Processing user: $user"
            
            # Check if user's private key already exists in S3
            if aws s3 ls s3://$BUCKET_NAME/keys/${user}_private_key 2>&1 > /dev/null; then
              echo "‚úÖ Key already exists for $user in S3, downloading existing key"
              
              # Download existing key from S3 to local temp directory
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_private_key /tmp/ssh_keys/${user}_private_key
              aws s3 cp s3://$BUCKET_NAME/keys/${user}_public_key /tmp/ssh_keys/${user}_public_key
              
              # Download other formats if they exist
              if aws s3 ls s3://$BUCKET_NAME/keys/${user}_universal.pem 2>&1 > /dev/null; then
                aws s3 cp s3://$BUCKET_NAME/keys/${user}_universal.pem /tmp/ssh_keys/${user}_universal.pem
              fi
              if aws s3 ls s3://$BUCKET_NAME/keys/${user}_putty.ppk 2>&1 > /dev/null; then
                aws s3 cp s3://$BUCKET_NAME/keys/${user}_putty.ppk /tmp/ssh_keys/${user}_putty.ppk
              fi
              
              echo "üì• Downloaded existing keys for $user from S3"
              
              # Mark this user as existing (no email needed)
              echo "$user:existing" >> /tmp/user_key_status.txt
            else
              echo "üÜï No existing key found for $user, uploading newly generated keys"
              
              # Upload all key formats to S3
              aws s3 cp /tmp/ssh_keys/${user}_private_key s3://$BUCKET_NAME/keys/${user}_private_key --sse AES256
              aws s3 cp /tmp/ssh_keys/${user}_public_key s3://$BUCKET_NAME/keys/${user}_public_key --sse AES256
              aws s3 cp /tmp/ssh_keys/${user}_universal.pem s3://$BUCKET_NAME/keys/${user}_universal.pem --sse AES256
              
              # Upload PuTTY format if it exists
              if [ -f "/tmp/ssh_keys/${user}_putty.ppk" ]; then
                aws s3 cp /tmp/ssh_keys/${user}_putty.ppk s3://$BUCKET_NAME/keys/${user}_putty.ppk --sse AES256
              fi
              
              echo "üì§ Uploaded all key formats for $user to S3"
              
              # Mark this user as new (email needed)
              echo "$user:new" >> /tmp/user_key_status.txt
            fi
            
            echo ""
          done
          
          echo "‚úÖ All keys processed in S3 bucket: $BUCKET_NAME"
          echo "üìä Summary: Existing keys preserved, new keys uploaded"
          
          # Show user status summary
          echo ""
          echo "üìã User Key Status Summary:"
          if [ -f /tmp/user_key_status.txt ]; then
            echo "New users (will receive emails):"
            grep ":new$" /tmp/user_key_status.txt | cut -d: -f1 | while read user; do
              echo "  ‚úÖ $user - New key generated and uploaded"
            done
            
            echo ""
            echo "Existing users (no emails sent):"
            grep ":existing$" /tmp/user_key_status.txt | cut -d: -f1 | while read user; do
              echo "  ‚ÑπÔ∏è  $user - Existing key preserved, no email needed"
            done
          fi
          
      - name: Install SSH Keys on EC2 Instance
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Installing SSH Keys on EC2 Instance ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          SSH_USER="ec2-user"
          
          echo "Connecting to EC2 instance at $EC2_IP (${{ env.EC2_IP_TYPE }} IP)..."
          
          # Test SSH connection first
          if ssh -i ~/.ssh/ec2-provisioning-key -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SSH_USER@$EC2_IP "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection established"
          else
            echo "‚ùå Failed to establish SSH connection"
              exit 1
            fi
          
          # Make the script executable
          chmod +x scripts/install_users.sh
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          # Install each user's public key using the script
          for user in $USERS; do
            if [ -f "/tmp/ssh_keys/${user}_public_key" ]; then
              echo "Installing key for user: $user"
              
              # Read the public key content
              PUBLIC_KEY=$(cat "/tmp/ssh_keys/${user}_public_key")
              
              # Call the user provisioning script
              echo "Running user provisioning script for $user..."
              if ./scripts/install_users.sh "$user" "$PUBLIC_KEY" "$SSH_USER" "$EC2_IP"; then
                echo "‚úÖ User $user provisioned successfully"
              else
                echo "‚ùå Failed to provision user $user"
              exit 1
              fi
            else
              echo "‚ùå SSH key for $user not found"
              exit 1
            fi
          done
          
          echo "‚úÖ All SSH keys installed on EC2 instance"
          
      - name: Verify User Access
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "=== Verifying User Access ==="
          
          EC2_IP="${{ env.EC2_INSTANCE_IP }}"
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          
          echo "üîç Verification Details:"
          echo "- EC2 Instance IP: $EC2_IP"
          echo "- Verification Timestamp: $TIMESTAMP"
          echo "- Total Users to Verify: $(echo $USERS | wc -w)"
          echo ""
          
          # Read usernames from users.yaml dynamically
          USERS=$(python3 -c "
          import yaml
          with open('users.yaml', 'r') as f:
              data = yaml.safe_load(f)
              users = [user['username'] for user in data['users']]
              print(' '.join(users))
          ")
          
          echo "üìã Users to verify: $USERS"
            echo ""
          
          # Test each user's SSH access with comprehensive verification
          for user in $USERS; do
            echo "üß™ Testing SSH access for user: $user"
            echo "   ‚îî‚îÄ Creating temporary key file..."
            
            # Create a temporary private key file for testing
            TEMP_KEY="/tmp/test_${user}_key"
            cp "/tmp/ssh_keys/${user}_private_key" "$TEMP_KEY"
            chmod 600 "$TEMP_KEY"
            
            echo "   ‚îî‚îÄ Testing basic SSH connection..."
            # Test basic SSH connection
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o ConnectTimeout=10 $user@$EC2_IP "echo '‚úÖ Basic SSH connection successful for $user'"; then
              echo "   ‚úÖ Basic SSH connection: SUCCESS"
            else
              echo "   ‚ùå Basic SSH connection: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing user identity and home directory..."
            # Test user identity and home directory access
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "whoami && pwd && echo 'Home directory contents:' && ls -la"; then
              echo "   ‚úÖ User identity and home directory: SUCCESS"
            else
              echo "   ‚ùå User identity and home directory: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Creating verification file in user's home directory..."
            # Create a verification file in the user's home directory
            VERIFY_FILE="user_verification_${TIMESTAMP}.txt"
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'User $user successfully logged in at $(date)' > ~/$VERIFY_FILE && echo 'Verification file created successfully' && ls -la ~/$VERIFY_FILE"; then
              echo "   ‚úÖ Verification file creation: SUCCESS"
              echo "   üìÑ File created: ~/$VERIFY_FILE"
            else
              echo "   ‚ùå Verification file creation: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing file write permissions..."
            # Test file write permissions
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo 'Testing write permissions at $(date)' >> ~/$VERIFY_FILE && echo 'Write permissions test: SUCCESS'"; then
              echo "   ‚úÖ File write permissions: SUCCESS"
            else
              echo "   ‚ùå File write permissions: FAILED"
              rm -f "$TEMP_KEY"
              exit 1
            fi
            
            echo "   ‚îî‚îÄ Displaying verification file contents..."
            # Display the verification file contents
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no $user@$EC2_IP "echo '=== Verification File Contents ===' && cat ~/$VERIFY_FILE && echo '=== End of File ==='"; then
              echo "   ‚úÖ File read access: SUCCESS"
            else
              echo "   ‚ùå File read access: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            echo "   ‚îî‚îÄ Testing SSH key authentication..."
            # Test SSH key authentication specifically
            if ssh -i "$TEMP_KEY" -o StrictHostKeyChecking=no -o PasswordAuthentication=no $user@$EC2_IP "echo 'SSH key authentication successful for $user'"; then
              echo "   ‚úÖ SSH key authentication: SUCCESS"
            else
              echo "   ‚ùå SSH key authentication: FAILED"
              rm -f "$TEMP_KEY"
            exit 1
          fi
          
            # Clean up temporary key
            rm -f "$TEMP_KEY"
            
            echo "üéâ User $user: ALL VERIFICATIONS PASSED ‚úÖ"
            echo "   ‚îî‚îÄ SSH access: ‚úÖ"
            echo "   ‚îî‚îÄ Home directory: ‚úÖ"
            echo "   ‚îî‚îÄ File creation: ‚úÖ"
            echo "   ‚îî‚îÄ Write permissions: ‚úÖ"
            echo "   ‚îî‚îÄ Read permissions: ‚úÖ"
            echo "   ‚îî‚îÄ Key authentication: ‚úÖ"
            echo ""
          done
          
          echo "üéä VERIFICATION COMPLETE! üéä"
          echo "‚úÖ All users can access EC2 instance successfully"
          echo "‚úÖ All users have proper file permissions"
          echo "‚úÖ All users can create and read files"
          echo "‚úÖ SSH key authentication working for all users"
          echo ""
          echo "üìã Verification Summary:"
          echo "- Total users verified: $(echo $USERS | wc -w)"
          echo "- Users: $USERS"
          echo "- Verification timestamp: $TIMESTAMP"
          echo "- All tests: PASSED ‚úÖ"
          
      - name: Create Terraform Variables (Simplified)
        run: |
          cd terraform
          echo "=== Creating Simplified Terraform Variables ==="
          
          # Create minimal terraform.tfvars for user provisioning
          # Note: instance_ids should be a list, not a string
          INSTANCE_IDS="${{ github.event.inputs.instance_ids }}"
          AWS_REGION="${{ inputs.aws_region }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          echo "instance_ids = [\"$INSTANCE_IDS\"]" > terraform.tfvars
          echo "aws_region = \"$AWS_REGION\"" >> terraform.tfvars
          echo "dry_run = $DRY_RUN" >> terraform.tfvars
          echo 'ssh_private_key_path = "~/.ssh/ec2-provisioning-key"' >> terraform.tfvars
          echo 'ssh_user = "ec2-user"' >> terraform.tfvars
          echo 'users_file = "../users.yaml"' >> terraform.tfvars
          
          echo "‚úÖ terraform.tfvars created with proper formatting"
          echo "Contents of terraform.tfvars:"
          cat terraform.tfvars
          
      - name: Terraform Init
        run: |
          cd terraform
          echo "=== Terraform Initialization ==="
          terraform init
          echo "‚úÖ Terraform initialized"
          
      - name: Terraform Plan
        run: |
          cd terraform
          echo "=== Terraform Plan ==="
          
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "Running in dry-run mode"
            terraform plan -var-file="terraform.tfvars"
          else
            terraform plan -var-file="terraform.tfvars" -out=tfplan
          fi
          
          echo "‚úÖ Terraform plan completed"
          
      - name: Terraform Apply
        if: github.event.inputs.dry_run != 'true'
        run: |
          cd terraform
          echo "=== Terraform Apply ==="
          
          if [ -f "tfplan" ]; then
            terraform apply -auto-approve tfplan
            echo "‚úÖ Terraform apply completed"
          else
            echo "‚ùå No plan file found"
            exit 1
          fi
          
      - name: Send SSH Keys via Email
        if: github.event.inputs.send_emails == 'true'
        run: |
          echo "=== Sending SSH Keys via Email (Python SMTP) ==="
          
          # Set SMTP configuration for UMB
          SMTP_HOST="mailhost.umb.com"
          SMTP_PORT="25"
          TEST_EMAIL="saran.alla@umb.com"
          
          echo "üìß SMTP Configuration:"
          echo "- Host: $SMTP_HOST"
          echo "- Port: $SMTP_PORT"
          echo "- Test Email: $TEST_EMAIL"
          echo ""
          
          # Create Python script for sending emails
          cat > /tmp/send_emails.py << 'EOF'
          import smtplib
          import yaml
          import os
          import sys
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from email.mime.application import MIMEApplication
          
          def send_ssh_key_email(username, full_name, user_email, instance_id, instance_ip, instance_name, smtp_host, smtp_port):
              """Send SSH key email using Python SMTP with multiple key formats as attachments"""
              
              # Create email message with multipart support
              msg = MIMEMultipart()
              msg['From'] = 'EC2-Provisioning <noreply@mailhost.umb.com>'
              msg['To'] = user_email
              msg['Subject'] = f'SSH Keys for EC2 Access - {username} (Multiple Formats)'
              
              # Create comprehensive email body with Windows and Linux instructions
              email_body = f"SSH Keys for EC2 Access - {username}\n"
              email_body += "==========================================\n\n"
              email_body += "User Information:\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Full Name: {full_name}\n"
              email_body += f"- Generated: {os.popen('date').read().strip()}\n\n"
              email_body += "Instance Details:\n"
              email_body += f"- Instance Name: {instance_name}\n"
              email_body += f"- Instance ID: {instance_id}\n"
              email_body += f"- IP Address: {instance_ip}\n"
              email_body += f"- SSH Port: 22\n\n"
              email_body += "üîë MULTIPLE KEY FORMATS PROVIDED:\n"
              email_body += "================================\n\n"
              email_body += "1. {username}_private_key - Standard RSA private key (Linux/Mac/Windows OpenSSH)\n"
              email_body += "2. {username}_universal.pem - PEM format (works with most SSH clients)\n"
              email_body += "3. {username}_putty.ppk - PuTTY format (Windows PuTTY users)\n\n"
              email_body += "üìã WHICH KEY TO USE:\n"
              email_body += "===================\n\n"
              email_body += "üñ•Ô∏è  WINDOWS USERS (Recommended: PuTTY):\n"
              email_body += "   - Use: {username}_putty.ppk\n"
              email_body += "   - Download PuTTY: https://www.putty.org/\n"
              email_body += "   - Connection: Host: {instance_ip}, Port: 22, Username: {username}\n\n"
              email_body += "üñ•Ô∏è  WINDOWS USERS (Alternative: OpenSSH):\n"
              email_body += "   - Use: {username}_universal.pem\n"
              email_body += "   - Windows 10/11 built-in SSH client\n"
              email_body += "   - Command: ssh -i {username}_universal.pem {username}@{instance_ip}\n\n"
              email_body += "üêß LINUX/MAC USERS:\n"
              email_body += "   - Use: {username}_private_key or {username}_universal.pem\n"
              email_body += "   - Command: ssh -i ~/.ssh/{username}_private_key {username}@{instance_ip}\n\n"
              email_body += "üîí SECURITY IMPORTANT:\n"
              email_body += "====================\n"
              email_body += "- Keep private keys secure and never share them\n"
              email_body += "- Store keys in a secure directory\n"
              email_body += "- Never commit private keys to version control\n"
              email_body += "- Each key is unique to your user account\n\n"
              email_body += "üìñ DETAILED SETUP INSTRUCTIONS:\n"
              email_body += "================================\n\n"
              email_body += "üñ•Ô∏è  WINDOWS SETUP (PuTTY - Recommended):\n"
              email_body += "1. Download and install PuTTY from https://www.putty.org/\n"
              email_body += "2. Open PuTTY\n"
              email_body += "3. Enter Host Name: {instance_ip}\n"
              email_body += "4. Set Port: 22\n"
              email_body += "5. Go to Connection > SSH > Auth > Credentials\n"
              email_body += "6. Browse and select: {username}_putty.ppk\n"
              email_body += "7. Go back to Session, enter a name and save\n"
              email_body += "8. Click Open and enter username: {username}\n\n"
              email_body += "üñ•Ô∏è  WINDOWS SETUP (OpenSSH - Alternative):\n"
              email_body += "1. Save {username}_universal.pem to C:\\Users\\{username}\\.ssh\\\n"
              email_body += "2. Open Command Prompt or PowerShell\n"
              email_body += "3. Run: ssh -i C:\\Users\\{username}\\.ssh\\{username}_universal.pem {username}@{instance_ip}\n\n"
              email_body += "üêß LINUX/MAC SETUP:\n"
              email_body += "1. Save {username}_private_key to ~/.ssh/\n"
              email_body += "2. Set permissions: chmod 600 ~/.ssh/{username}_private_key\n"
              email_body += "3. Connect: ssh -i ~/.ssh/{username}_private_key {username}@{instance_ip}\n\n"
              email_body += "üîß TROUBLESHOOTING:\n"
              email_body += "==================\n"
              email_body += "- Connection fails: Check IP address and username\n"
              email_body += "- Permission denied: Verify key file permissions\n"
              email_body += "- Key format error: Use the correct format for your SSH client\n"
              email_body += "- Network issues: Ensure you're connecting from an allowed network\n\n"
              email_body += "üìû CONNECTION SUMMARY:\n"
              email_body += "====================\n"
              email_body += f"- Username: {username}\n"
              email_body += f"- Instance: {instance_name} ({instance_id})\n"
              email_body += f"- IP Address: {instance_ip}\n"
              email_body += f"- PuTTY: Use {username}_putty.ppk file\n"
              email_body += f"- OpenSSH: ssh -i {username}_universal.pem {username}@{instance_ip}\n"
              email_body += f"- Linux/Mac: ssh -i {username}_private_key {username}@{instance_ip}\n\n"
              email_body += "This is an automated message from the AWS EC2 User Provisioning System.\n"
              email_body += "If you have questions, contact your system administrator.\n\n"
              email_body += "üéØ RECOMMENDATION: Windows users should use PuTTY with the .ppk file for the best experience."
              
              # Attach the email body
              msg.attach(MIMEText(email_body, 'plain', 'utf-8'))
              
              # Attach all three key formats
              # 1. Standard RSA private key
              if os.path.exists(f'/tmp/ssh_keys/{username}_private_key'):
                  with open(f'/tmp/ssh_keys/{username}_private_key', 'r') as f:
                      key_content = f.read()
                  key_attachment = MIMEApplication(key_content.encode('utf-8'), _subtype='txt')
                  key_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_private_key')
                  msg.attach(key_attachment)
              
              # 2. Universal PEM format
              if os.path.exists(f'/tmp/ssh_keys/{username}_universal.pem'):
                  with open(f'/tmp/ssh_keys/{username}_universal.pem', 'r') as f:
                      pem_content = f.read()
                  pem_attachment = MIMEApplication(pem_content.encode('utf-8'), _subtype='txt')
                  pem_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_universal.pem')
                  msg.attach(pem_attachment)
              
              # 3. PuTTY format (.ppk)
              if os.path.exists(f'/tmp/ssh_keys/{username}_putty.ppk'):
                  with open(f'/tmp/ssh_keys/{username}_putty.ppk', 'r') as f:
                      ppk_content = f.read()
                  ppk_attachment = MIMEApplication(ppk_content.encode('utf-8'), _subtype='txt')
                  ppk_attachment.add_header('Content-Disposition', 'attachment', filename=f'{username}_putty.ppk')
                  msg.attach(ppk_attachment)
              
              try:
                  # Connect to SMTP server
                  print(f"üìß Connecting to SMTP server {smtp_host}:{smtp_port}...")
                  server = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
                  
                  # Start TLS if supported
                  try:
                      server.starttls()
                      print("‚úÖ TLS connection established")
                  except:
                      print("‚ÑπÔ∏è  TLS not supported, continuing without encryption")
                  
                  # Send email
                  print(f"üì§ Sending email to {user_email} for user {username}...")
                  server.send_message(msg)
                  server.quit()
                  
                  print(f"‚úÖ Email sent successfully for user {username} to {user_email}")
                  print(f"üìé Private key attached as: {username}_private_key")
                  return True
                  
              except Exception as e:
                  print(f"‚ùå Failed to send email for user {username} to {user_email}: {str(e)}")
                  return False
          
          def main():
              # Configuration
              smtp_host = os.environ.get('SMTP_HOST', 'mailhost.umb.com')
              smtp_port = int(os.environ.get('SMTP_PORT', '25'))
              
              # Get instance details from environment variables
              instance_id = os.environ.get('EC2_INSTANCE_ID', 'Unknown')
              instance_ip = os.environ.get('EC2_INSTANCE_IP', 'Unknown')
              instance_name = os.environ.get('EC2_INSTANCE_NAME', 'EC2 Instance')
              
              print(f"üè† Instance Details:")
              print(f"   - ID: {instance_id}")
              print(f"   - IP: {instance_ip}")
              print(f"   - Name: {instance_name}")
              print()
              
              # Read user key status from the file created by the S3 step
              user_key_status = {}
              try:
                  with open('/tmp/user_key_status.txt', 'r') as f:
                      for line in f:
                          line = line.strip()
                          if ':' in line:
                              username, status = line.split(':', 1)
                              user_key_status[username] = status
                  print(f"üìã User key status loaded: {len(user_key_status)} users")
              except FileNotFoundError:
                  print("‚ö†Ô∏è  User key status file not found, treating all users as new")
              except Exception as e:
                  print(f"‚ö†Ô∏è  Error reading user key status: {e}")
              
              # Read users from users.yaml
              try:
                  with open('users.yaml', 'r') as f:
                      data = yaml.safe_load(f)
                      users = data['users']
                      print(f"üìã Found {len(users)} users to process")
                      print()
              except Exception as e:
                  print(f"‚ùå Error reading users.yaml: {e}")
                  return 1
              
              # Process each user
              success_count = 0
              total_count = len(users)
              new_users_count = 0
              existing_users_count = 0
              
              for user_data in users:
                  username = user_data['username']
                  full_name = user_data['full_name']
                  user_email = user_data.get('email')
                  
                  # Skip users without email addresses
                  if not user_email:
                      print(f"‚ö†Ô∏è  Skipping user {username} - no email address found")
                      continue
                  
                  # Check if this user is new or existing based on key status
                  user_status = user_key_status.get(username, 'new')  # Default to 'new' if status unknown
                  
                  if user_status == 'existing':
                      print(f"‚ÑπÔ∏è  User {username} ({full_name}) - Existing key preserved, skipping email")
                      existing_users_count += 1
                      continue
                  elif user_status == 'new':
                      print(f"üÜï User {username} ({full_name}) - New key generated, sending email to {user_email}")
                      new_users_count += 1
                  else:
                      print(f"‚ùì User {username} ({full_name}) - Unknown status '{user_status}', treating as new user")
                      new_users_count += 1
                  
                  # Check if key files exist
                  key_files_exist = True
                  required_files = [
                      f"/tmp/ssh_keys/{username}_private_key",
                      f"/tmp/ssh_keys/{username}_universal.pem"
                  ]
                  
                  for key_file in required_files:
                      if not os.path.exists(key_file):
                          print(f"‚ö†Ô∏è  Required key file not found: {key_file}")
                          key_files_exist = False
                          break
                  
                  if not key_files_exist:
                      print(f"‚ö†Ô∏è  Missing required key files for {username}")
                      continue
                  
                  print(f"‚úÖ All key formats available for {username}")
                  
                  # Send email only to new users
                  if send_ssh_key_email(username, full_name, user_email, 
                                     instance_id, instance_ip, instance_name,
                                     smtp_host, smtp_port):
                      success_count += 1
                      print(f"üìß Email sent to {user_email} for user {username}")
                  else:
                      print(f"‚ùå Failed to send email for user {username}")
                  
                  print()
              
              # Summary
              print("=== Email Delivery Summary ===")
              print(f"Total users processed: {total_count}")
              print(f"New users (emails sent): {new_users_count}")
              print(f"Existing users (no emails): {existing_users_count}")
              print(f"Emails sent successfully: {success_count}")
              print(f"Emails failed: {new_users_count - success_count}")
              print()
              
              if success_count > 0:
                  print(f"‚úÖ SSH keys processed successfully for {success_count} new users")
                  print(f"üìß Only new users received emails with their keys")
                  print(f"‚ÑπÔ∏è  Existing users maintained their access without emails")
                  return 0
              else:
                  print("‚ùå No emails were processed successfully")
                  return 1
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Set environment variables for Python script
          export SMTP_HOST="$SMTP_HOST"
          export SMTP_PORT="$SMTP_PORT"
          export EC2_INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"
          export EC2_INSTANCE_IP="${{ env.EC2_INSTANCE_IP }}"
          export EC2_INSTANCE_NAME="EC2 Instance"
          
          # Try to get instance name from AWS if available
          if command -v aws &> /dev/null && [ -n "${{ env.EC2_INSTANCE_ID }}" ]; then
            echo "üîç Getting instance details from AWS..."
            instance_name=$(aws ec2 describe-instances --instance-ids "${{ env.EC2_INSTANCE_ID }}" --query 'Reservations[0].Instances[0].Tags[?Key==`Name`].Value' --output text 2>/dev/null || echo "EC2 Instance")
            export EC2_INSTANCE_NAME="$instance_name"
            echo "‚úÖ Instance name: $instance_name"
          fi
          
          # Run Python script
          echo "üêç Running Python SMTP script..."
          python3 /tmp/send_emails.py
          
          # Clean up
          rm -f /tmp/send_emails.py
          
          echo ""
          echo "üìß Email Summary:"
          echo "- SMTP Server: $SMTP_HOST:$SMTP_PORT"
          echo "- Each user receives their SSH key at their own email address"
          echo "- Python SMTP implementation completed"
          
      - name: Cleanup
        run: |
          echo "=== Cleanup ==="
          rm -rf /tmp/ssh_keys
          echo "‚úÖ Temporary files cleaned up"
          
      - name: Success Summary
        run: |
          echo ""
          echo "üéâ USER PROVISIONING COMPLETED SUCCESSFULLY! üéâ"
          echo ""
          echo "üìã Summary:"
          echo "- EC2 Instance: ${{ env.EC2_INSTANCE_ID }}"
          echo "- IP Address: ${{ env.EC2_INSTANCE_IP }} (${{ env.EC2_IP_TYPE }} IP)"
          echo "- Users Created: $USERS"
          echo "- SSH Keys: Available in S3 bucket and sent via email"
          echo "- Access Verified: All users can SSH to EC2"
          echo ""
          echo "üîç Verification Details:"
          echo "- Verification Timestamp: $(date +"%Y%m%d-%H%M%S")"
          echo "- Verification Files Created: user_verification_*.txt in each user's home directory"
          echo "- All Users Tested: SSH access, file creation, read/write permissions, key authentication"
          echo ""
          echo "‚úÖ Verification Results:"
          echo "- SSH Access: All users can connect successfully"
          echo "- File Operations: All users can create, read, and write files"
          echo "- Permissions: All users have proper home directory access"
          echo "- Authentication: SSH key-based authentication working for all users"
          echo ""
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "üìß Email Delivery:"
            echo "- Each user received their SSH private key at their own email address"
            echo "- SMTP Server: mailhost.umb.com:25"
            echo "- Keys delivered: 6 private keys with instructions"
            echo ""
          fi
          echo "üîë Next Steps:"
          echo "1. SSH keys available in S3 bucket: ec2-user-provisioning-keys"
          if [ "${{ github.event.inputs.send_emails }}" = "true" ]; then
            echo "2. Check email at your own email address for SSH keys"
          fi
          echo "3. Users connect: ssh -i user_key user@${{ env.EC2_INSTANCE_IP }}"
          echo "4. All users have full access to their home directories"
          echo "5. Verification files created: ~/user_verification_*.txt"
          echo ""
          echo "üéØ No manual verification needed - all tests passed automatically!"

 